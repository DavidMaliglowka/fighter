<!DOCTYPE html>
<html>
<head>
    <title>Fighter Game</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="platforms.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            border: 2px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 1000;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 1000;
        }
        #respawn-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ff6666;
            padding: 30px;
            border-radius: 15px;
            font-size: 64px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 2000;
            border: 3px solid #ff6666;
            box-shadow: 0 0 30px rgba(255, 102, 102, 0.5);
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="player-count">Players: 0</div>
        <div id="health">Health: 100</div>
        <div id="lives">Lives: 3</div>
        <div id="match-status"></div>
    </div>
    <div id="game-container"></div>
    <div id="respawn-countdown"></div>
    <div id="controls">
        <div>Controls:</div>
        <div>Left/Right: Move</div>
        <div>Up: Jump</div>
        <div>Down: Drop through platforms</div>
        <div>Space: Attack</div>
        <div>Z: Block</div>
        <div>Shift+Arrow: Dash</div>
        <div>Double-tap Arrow: Dash</div>
        <div>P: Toggle Prediction</div>
    </div>
    
    <div id="prediction-debug" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px;">
        <div>Prediction: <span id="prediction-status">ON</span></div>
        <div>Position Error: <span id="position-error">0.0</span>px</div>
        <div>Buffer Size: <span id="buffer-size">0</span></div>
        <div>Last Update: <span id="last-update">0</span>ms ago</div>
        <div>Input Status: <span id="input-status">Normal</span></div>
    </div>
    
    <script>
        // Phaser game configuration
        const config = {
            type: Phaser.AUTO,
            width: 1200, // Expanded from 800 to allow fall-off movement
            height: 1000, // Expanded from 600 to allow fall recovery attempts
            parent: 'game-container',
            backgroundColor: '#2c5f2d',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 }, // Server handles gravity
                    debug: false // Server handles collision detection
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // Create the game
        const game = new Phaser.Game(config);

        let cursors;
        let socket;
        let spaceKey;
        let zKey;
        let shiftKey; // Dedicated dash key
        let platforms; // Platform physics group
        
        // Dash input detection variables
        let lastLeftKeyTime = 0;
        let lastRightKeyTime = 0;
        let dashInputCooldown = 0; // Prevent multiple dash triggers
        const DASH_DOUBLE_TAP_WINDOW = 250; // ms
        const DASH_INPUT_COOLDOWN = 100; // ms to prevent multiple triggers
        
        const playerSprites = {};
        const playerHealthBars = {};
        const playerAttackEffects = {};
        let myPlayerId = null;
        let gameState = { players: {} };
        
        // Client-side prediction variables
        let clientPlayerState = null;
        let inputBuffer = [];
        let lastServerUpdate = 0;
        let predictionEnabled = true;
        const PHYSICS_CONSTANTS = {
            GRAVITY: 800,
            GROUND_Y: 560,
            FRAME_RATE: 60,
            JUMP_VELOCITY_SINGLE: -500,
            JUMP_VELOCITY_DOUBLE: -400
        };

        function preload() {
            // Create simple colored rectangles for sprites - extend background
            this.add.graphics()
                .fillStyle(0x333333)
                .fillRect(0, 0, 1200, 1000);
                
            // Add visual indicators for the main play area (800px center)
            this.add.graphics()
                .lineStyle(2, 0x555555)
                .strokeRect(200, 0, 800, 600); // Main play area outline
                
                            // Add visual indicator for death zone
                this.add.graphics()
                    .lineStyle(2, 0xff3333, 0.5)
                    .strokeRect(0, 950, 1200, 2); // Death boundary line
                    
                // Add ground extension visual so players can see fall zone
                this.add.graphics()
                    .fillStyle(0x4a4a4a) // Darker ground color
                    .fillRect(200, 600, 800, 350) // Extended ground area
                    .lineStyle(2, 0x666666)
                    .strokeRect(200, 600, 800, 350);
                    
                // Add danger text in the pit
                this.add.text(600, 800, 'DANGER ZONE', {
                    fontSize: '24px',
                    fill: '#ff3333',
                    stroke: '#000000',
                    strokeThickness: 2
                }).setOrigin(0.5).setAlpha(0.7);
                
                // Add side cliff walls to show fall-off areas
                this.add.graphics()
                    .fillStyle(0x8B4513) // Brown cliff color
                    .fillRect(0, 600, 200, 350) // Left cliff
                    .fillRect(1000, 600, 200, 350); // Right cliff
        }

        // Platforms are now server-side only - no client collision callbacks needed

        function create() {
            // Create platform physics group (static - they don't move)
            platforms = this.physics.add.staticGroup();
            
            // Create all platforms from configuration
            if (window.PlatformConfig) {
                const { PLATFORMS, PLATFORM_COLORS } = window.PlatformConfig;
                
                PLATFORMS.forEach(platformData => {
                    // Create platform sprite with proper color
                    const color = PLATFORM_COLORS[platformData.type];
                    const platform = this.add.rectangle(
                        platformData.x + 200, // Offset by 200px to center in 1200px canvas
                        platformData.y,
                        platformData.width,
                        platformData.height,
                        color
                    );
                    
                    // Add physics body to the platform
                    platforms.add(platform);
                    
                    // Store platform data for collision detection
                    platform.platformData = platformData;
                });
                
                console.log(`Created ${PLATFORMS.length} platforms`);
            } else {
                console.error('Platform configuration not loaded!');
                // Fallback to original ground
                this.add.rectangle(400, 580, 800, 40, 0x8B4513);
            }
            
            // Add some background elements (offset for centered play area)
            this.add.rectangle(300, 100, 20, 100, 0x654321); // Tree trunk (100 + 200 offset)
            this.add.circle(300, 80, 40, 0x228B22); // Tree leaves
            this.add.rectangle(900, 120, 20, 80, 0x654321); // Tree trunk (700 + 200 offset)
            this.add.circle(900, 100, 35, 0x228B22); // Tree leaves
            
            cursors = this.input.keyboard.createCursorKeys();
            spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            zKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
            
            // Dash input keys
            shiftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
            
            // Set camera bounds to show the full expanded area
            this.cameras.main.setBounds(0, 0, 1200, 1000);
            // Center camera on the main play area initially  
            this.cameras.main.setScroll(0, 0);
            
            // Store reference to scene for collision callbacks
            window.gameScene = this;
            
            // Prediction toggle key
            const pKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
            pKey.on('down', () => {
                predictionEnabled = !predictionEnabled;
                if (!predictionEnabled) {
                    clientPlayerState = null; // Reset client state
                }
                updateDebugPanel();
            });
            
            socket = io();
            myPlayerId = socket.id;
            
            socket.on('gameState', (newGameState) => {
                gameState = newGameState;
                
                // Client-side prediction reconciliation
                if (predictionEnabled && myPlayerId) {
                    reconcileWithServer(newGameState);
                }
                
                updatePlayerCount();
                updatePlayerSprites.call(this);
                updateUI();
            });
            
            socket.on('connect', () => {
                myPlayerId = socket.id;
            });
            
            // Listen for jump events for visual effects
            socket.on('playerJump', (jumpEvent) => {
                handleJumpEvent.call(this, jumpEvent);
            });
            
            // Listen for dash events for visual effects
            socket.on('playerDash', (dashEvent) => {
                handleDashEvent.call(this, dashEvent);
            });
            
            // Listen for death events
            socket.on('playerDeath', (deathEvent) => {
                handlePlayerDeath.call(this, deathEvent);
            });
            
            // Listen for respawn events
            socket.on('playerRespawn', (respawnEvent) => {
                handlePlayerRespawn.call(this, respawnEvent);
            });
            
            // Listen for elimination events
            socket.on('playerEliminated', (eliminationEvent) => {
                handlePlayerElimination.call(this, eliminationEvent);
            });
            
            // Listen for match end events
            socket.on('matchEnd', (matchEndEvent) => {
                handleMatchEnd.call(this, matchEndEvent);
            });
            
            // Listen for match reset events
            socket.on('matchReset', (resetEvent) => {
                handleMatchReset.call(this, resetEvent);
            });
            
            // Listen for invincibility end events
            socket.on('playerInvincibilityEnd', (invincibilityEvent) => {
                handleInvincibilityEnd.call(this, invincibilityEvent);
            });
        }

        function updatePlayerSprites() {
            // Remove sprites for disconnected players
            for (const id in playerSprites) {
                if (!gameState.players[id]) {
                    playerSprites[id].destroy();
                    playerHealthBars[id].background.destroy();
                    playerHealthBars[id].fill.destroy();
                    if (playerAttackEffects[id]) {
                        playerAttackEffects[id].destroy();
                    }
                    delete playerSprites[id];
                    delete playerHealthBars[id];
                    delete playerAttackEffects[id];
                }
            }
            
            // Update or create sprites for connected players
            for (const id in gameState.players) {
                const player = gameState.players[id];
                
                if (!playerSprites[id]) {
                    // Create new player sprite with physics body
                    const color = id === myPlayerId ? 0xff0000 : 0x0000ff;
                    playerSprites[id] = this.add.rectangle(player.x + 200, player.y, 40, 60, color); // Offset by 200px
                    
                    // Store player ID on sprite for reference
                    playerSprites[id].playerId = id;
                    
                    // Create health bar background
                    const healthBarBg = this.add.rectangle(player.x + 200, player.y - 40, 50, 8, 0x333333);
                    const healthBarFill = this.add.rectangle(player.x + 200, player.y - 40, 48, 6, 0x00ff00);
                    
                    playerHealthBars[id] = {
                        background: healthBarBg,
                        fill: healthBarFill
                    };
                    
                    // Create attack effect (initially invisible)
                    playerAttackEffects[id] = this.add.circle(player.x + 200, player.y, 35, 0xffff00, 0.6);
                    playerAttackEffects[id].setVisible(false);
                } else {
                    // Update existing sprite position (server handles physics)
                    // Skip position update for local player if prediction is enabled
                    if (!(predictionEnabled && id === myPlayerId)) {
                        playerSprites[id].setPosition(player.x + 200, player.y); // Add 200px offset
                    }
                    
                    // Update player color based on state
                    let playerColor = id === myPlayerId ? 0xff0000 : 0x0000ff;
                    let playerAlpha = 1.0;
                    
                    if (player.eliminated) {
                        playerColor = 0x333333; // Dark gray when eliminated
                        playerAlpha = 0.5;
                    } else if (player.isDead) {
                        playerColor = 0x666666; // Gray when dead
                        playerAlpha = 0.3;
                    } else if (player.isInvincible) {
                        playerColor = 0x00ffff; // Cyan when invincible
                        playerAlpha = 0.7 + Math.sin(Date.now() * 0.01) * 0.3; // Blinking effect
                    } else if (player.blocking) {
                        playerColor = 0xffff00; // Yellow when blocking
                    } else if (player.health <= 0) {
                        playerColor = 0x666666; // Gray when health is 0
                    }
                    
                    playerSprites[id].setFillStyle(playerColor);
                    playerSprites[id].setAlpha(playerAlpha);
                    
                    // Update health bar position and fill
                    // Use predicted position for local player, server position for others
                    const healthBarX = (predictionEnabled && id === myPlayerId && clientPlayerState) ? 
                        clientPlayerState.x + 200 : player.x + 200; // Add 200px offset
                    const healthBarY = (predictionEnabled && id === myPlayerId && clientPlayerState) ? 
                        clientPlayerState.y - 40 : player.y - 40;
                    
                    playerHealthBars[id].background.x = healthBarX;
                    playerHealthBars[id].background.y = healthBarY;
                    playerHealthBars[id].fill.x = healthBarX;
                    playerHealthBars[id].fill.y = healthBarY;
                    
                    // Update health bar width based on health
                    const healthPercent = player.health / 100;
                    playerHealthBars[id].fill.scaleX = healthPercent;
                    
                    // Update health bar color based on health
                    if (healthPercent > 0.6) {
                        playerHealthBars[id].fill.setFillStyle(0x00ff00);
                    } else if (healthPercent > 0.3) {
                        playerHealthBars[id].fill.setFillStyle(0xffff00);
                    } else {
                        playerHealthBars[id].fill.setFillStyle(0xff0000);
                    }
                    
                    // Update attack effect
                    if (player.attacking && playerAttackEffects[id]) {
                        playerAttackEffects[id].x = player.x + 200; // Add 200px offset
                        playerAttackEffects[id].y = player.y;
                        playerAttackEffects[id].setVisible(true);
                    } else if (playerAttackEffects[id]) {
                        playerAttackEffects[id].setVisible(false);
                    }
                }
            }
        }

        function updatePlayerCount() {
            const count = Object.keys(gameState.players).length;
            document.getElementById('player-count').textContent = `Players: ${count}`;
        }

        function updateUI() {
            const myPlayer = gameState.players[myPlayerId];
            if (myPlayer) {
                document.getElementById('health').textContent = `Health: ${myPlayer.health}`;
                document.getElementById('lives').textContent = `Lives: ${myPlayer.lives}`;
                
                // Update match status
                const statusElement = document.getElementById('match-status');
                if (myPlayer.eliminated) {
                    statusElement.textContent = 'ELIMINATED - Spectating';
                    statusElement.style.color = '#ff6666';
                } else if (myPlayer.isDead) {
                    statusElement.textContent = 'RESPAWNING...';
                    statusElement.style.color = '#ffff66';
                } else if (myPlayer.isInvincible) {
                    statusElement.textContent = 'INVINCIBLE';
                    statusElement.style.color = '#66ffff';
                } else {
                    statusElement.textContent = '';
                }
            }
        }

        function update() {
            const currentTime = Date.now();
            
            // Dash input detection system
            let dashDirection = null; // null, 'left', or 'right'
            
            // Update dash input cooldown
            if (dashInputCooldown > 0) {
                dashInputCooldown -= 16.67; // Approximate frame time (60fps)
            }
            
            // Check for dedicated dash key (Shift) + direction
            if (Phaser.Input.Keyboard.JustDown(shiftKey) && dashInputCooldown <= 0) {
                if (cursors.left.isDown) {
                    dashDirection = 'left';
                    dashInputCooldown = DASH_INPUT_COOLDOWN;
                } else if (cursors.right.isDown) {
                    dashDirection = 'right';
                    dashInputCooldown = DASH_INPUT_COOLDOWN;
                }
            }
            
            // Check for double-tap dash (left/right keys)
            if (dashInputCooldown <= 0) {
                // Left key double-tap detection
                if (Phaser.Input.Keyboard.JustDown(cursors.left)) {
                    if (currentTime - lastLeftKeyTime <= DASH_DOUBLE_TAP_WINDOW) {
                        dashDirection = 'left';
                        dashInputCooldown = DASH_INPUT_COOLDOWN;
                    }
                    lastLeftKeyTime = currentTime;
                }
                
                // Right key double-tap detection  
                if (Phaser.Input.Keyboard.JustDown(cursors.right)) {
                    if (currentTime - lastRightKeyTime <= DASH_DOUBLE_TAP_WINDOW) {
                        dashDirection = 'right';
                        dashInputCooldown = DASH_INPUT_COOLDOWN;
                    }
                    lastRightKeyTime = currentTime;
                }
            }
            
            const inputs = {
                left: cursors.left.isDown,
                right: cursors.right.isDown,
                jump: Phaser.Input.Keyboard.JustDown(cursors.up),
                attack: Phaser.Input.Keyboard.JustDown(spaceKey),
                block: zKey.isDown,
                down: cursors.down.isDown,
                dash: dashDirection // Add dash direction to inputs
            };
            
            // Client-side prediction for smooth gameplay
            if (predictionEnabled && myPlayerId && gameState.players[myPlayerId]) {
                // Initialize client state if needed
                if (!clientPlayerState) {
                    initializeClientPlayerState();
                }
                
                // Apply inputs immediately on client for responsiveness
                applyClientSidePrediction(inputs);
                
                // Buffer input for server reconciliation
                bufferInput(inputs);
            }
            
            socket.emit('input', inputs);
        }
        
        // Client-side prediction functions
        function initializeClientPlayerState() {
            const serverPlayer = gameState.players[myPlayerId];
            if (!serverPlayer) return;
            
            // Perfect sync with server state
            clientPlayerState = {
                x: serverPlayer.x,
                y: serverPlayer.y,
                velocityX: serverPlayer.velocityX || 0,
                velocityY: serverPlayer.velocityY || 0,
                isGrounded: serverPlayer.isGrounded !== undefined ? serverPlayer.isGrounded : true,
                jumpsRemaining: serverPlayer.jumpsRemaining || 2,
                lastJumpTime: serverPlayer.lastJumpTime || 0,
                blocking: serverPlayer.blocking || false,
                health: serverPlayer.health,
                droppingTimer: 0, // frames left to ignore one-way collisions
                isDashing: false, // New for dash state
                dashDirection: 0, // New for dash direction
                dashStartTime: 0, // New for dash start time
                lastDashTime: 0, // New for last dash time
                dashVelocity: 0 // New for dash velocity
            };
            
            // Force immediate position sync to eliminate initial error
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                updateLocalPlayerHealthBar();
            }
        }
        
        function updateLocalPlayerHealthBar() {
            if (predictionEnabled && myPlayerId && clientPlayerState && playerHealthBars[myPlayerId]) {
                const healthBarX = clientPlayerState.x + 200; // Add 200px offset
                const healthBarY = clientPlayerState.y - 40;
                
                playerHealthBars[myPlayerId].background.x = healthBarX;
                playerHealthBars[myPlayerId].background.y = healthBarY;
                playerHealthBars[myPlayerId].fill.x = healthBarX;
                playerHealthBars[myPlayerId].fill.y = healthBarY;
            }
        }

        // Utility: returns true if we should ignore one-way platforms this frame
        function isDroppingThrough() {
            return clientPlayerState && clientPlayerState.droppingTimer && clientPlayerState.droppingTimer > 0;
        }

        function getClientGroundState(player, ignoreOneWay) {
            const { PLATFORMS, PLATFORM_TYPES, PLATFORM_PHYSICS, PlatformUtils } = window.PlatformConfig;

            let isGrounded = false;
            let groundY = PHYSICS_CONSTANTS.GROUND_Y; // default ground level
            let landedPlatform = null;

            const halfPlayerHeight = PLATFORM_PHYSICS.PLAYER_HEIGHT / 2;

            for (const platform of PLATFORMS) {
                const playerBounds = PlatformUtils.getPlayerBounds(player);
                const platformBounds = PlatformUtils.getPlatformBounds(platform);

                // Horizontal overlap check
                const horizontallyOverlapping = playerBounds.left < platformBounds.right &&
                                                playerBounds.right > platformBounds.left;
                if (!horizontallyOverlapping) continue;

                const platformTop = platform.y - platform.height / 2;
                const playerBottom = player.y + halfPlayerHeight;
                const distToTop = playerBottom - platformTop;

                // Within landing tolerance and falling/downwards movement
                const nearPlatform = distToTop >= -20 && distToTop <= 20;

                if (nearPlatform && player.velocityY >= 0) {
                    if (platform.type === PLATFORM_TYPES.ONE_WAY) {
                        // Ignore collision while dropping through
                        if (ignoreOneWay || isDroppingThrough()) {
                            continue;
                        }
                        // Can only land if coming from above the platform
                        if (player.y < platformTop) {
                            isGrounded = true;
                            groundY = PlatformUtils.getPlayerStandingY(platform);
                            landedPlatform = platform;
                            break;
                        }
                    } else {
                        // SOLID / SPAWN platforms – collide from any direction (primarily above)
                        isGrounded = true;
                        groundY = PlatformUtils.getPlayerStandingY(platform);
                        landedPlatform = platform;
                        break;
                    }
                }
            }

            // Fallback to ground level if nothing else
            if (!isGrounded && player.y >= PHYSICS_CONSTANTS.GROUND_Y) {
                isGrounded = true;
                groundY = PHYSICS_CONSTANTS.GROUND_Y;
            }

            return { isGrounded, groundY, platform: landedPlatform };
        }
 
        function applyClientSidePrediction(inputs) {
            const deltaTime = 1 / PHYSICS_CONSTANTS.FRAME_RATE;
            const now = Date.now();
            
            // Apply same anti-cheat logic as server: prevent conflicting inputs
            let inputsCancelled = false;
            if (inputs.left && inputs.right) {
                inputs.left = false;
                inputs.right = false;
                inputsCancelled = true;
            }
            
            // Update debug panel input status
            const inputStatusElement = document.getElementById('input-status');
            if (inputStatusElement) {
                if (inputsCancelled) {
                    inputStatusElement.textContent = 'CANCELLED (L+R)';
                    inputStatusElement.style.color = '#ff6666';
                } else {
                    inputStatusElement.textContent = 'Normal';
                    inputStatusElement.style.color = '#66ff66';
                }
            }
            
            // Movement prediction with improved accuracy
            const moveSpeed = clientPlayerState.blocking ? 2 : 4; // Match server MOVEMENT_SPEED
            
            // Better direction change handling - reset velocity first
            let newVelocityX = 0;
            
            if (inputs.left) {
                newVelocityX = -moveSpeed;
                clientPlayerState.x -= moveSpeed;
            } else if (inputs.right) {
                newVelocityX = moveSpeed;
                clientPlayerState.x += moveSpeed;
            }
            
            // Immediately update velocity to match server behavior
            clientPlayerState.velocityX = newVelocityX;
            
            // Jump prediction with exact server matching
            if (inputs.jump && validateClientJump(now)) {
                performClientJump(now);
            }
            
            // Dash prediction with client-side validation
            if (inputs.dash && validateClientDash(now)) {
                performClientDash(inputs.dash, now);
            }
            
            // ---------------------------------------------------------------------------
            // Vertical movement & collision (platform-aware)
            // ---------------------------------------------------------------------------

            const ignoreOneWayNow = inputs.down || isDroppingThrough(); // hold or active drop
            // Evaluate current ground state BEFORE movement
            let groundState = getClientGroundState(clientPlayerState, ignoreOneWayNow);

            // Allow drop-through ONLY when on a ONE_WAY platform
            const wantsToDrop = inputs.down && groundState.isGrounded &&
                                groundState.platform && groundState.platform.type === window.PlatformConfig.PLATFORM_TYPES.ONE_WAY;

            if (wantsToDrop) {
                // Initiate a small downward velocity so gravity takes over
                clientPlayerState.velocityY = Math.max(clientPlayerState.velocityY, 200); // faster pass-through
                clientPlayerState.droppingTimer = 12; // ignore one-way collisions for ~200ms (12 frames)
                groundState.isGrounded = false;
                clientPlayerState.isGrounded = false;
            }

            // Decrement droppingTimer each frame
            if (clientPlayerState.droppingTimer && clientPlayerState.droppingTimer > 0) {
                clientPlayerState.droppingTimer--;
            }

            // Apply gravity when not grounded
            if (!groundState.isGrounded) {
                clientPlayerState.velocityY += PHYSICS_CONSTANTS.GRAVITY * deltaTime;
                // Proposed next position
                const candidateY = clientPlayerState.y + clientPlayerState.velocityY * deltaTime;
                // If we would overshoot a SOLID/SPAWN platform or ground, clamp smoothly
                if (groundState.isGrounded && candidateY > groundState.groundY &&
                    (!groundState.platform || groundState.platform.type !== window.PlatformConfig.PLATFORM_TYPES.ONE_WAY || !ignoreOneWayNow)) {
                    clientPlayerState.y = groundState.groundY;
                } else {
                    clientPlayerState.y = candidateY;
                }
            }

            // Re-evaluate ground state AFTER movement to clamp to platforms/ground
            groundState = getClientGroundState(clientPlayerState, ignoreOneWayNow);

            // Smoothly settle onto platform/ground to remove visible gaps without hard snap
            if (groundState.isGrounded) {
                const diff = groundState.groundY - clientPlayerState.y; // positive if below surface, negative if floating above
                const absDiff = Math.abs(diff);
                if (absDiff > 0.5) { // ignore sub-pixel noise
                    const settleFactor = absDiff > 8 ? 1 : 0.5; // big error – snap, small – glide
                    clientPlayerState.y += diff * settleFactor;
                }
            }

            const serverPlayer = gameState.players[myPlayerId];
            const serverAgreesGrounded = serverPlayer && serverPlayer.isGrounded;

            if (groundState.isGrounded && serverAgreesGrounded) {
                // Do not force exact Y; just stop vertical movement for smoothness
                clientPlayerState.velocityY = 0;
                if (!clientPlayerState.isGrounded) {
                    clientPlayerState.isGrounded = true;
                    clientPlayerState.jumpsRemaining = 2;
                }
            } else {
                clientPlayerState.isGrounded = false;
            }
            
            // Update blocking state
            clientPlayerState.blocking = inputs.block;
            
            // Allow free movement beyond boundaries for fall-off deaths
            // No horizontal clamping - players can now fall off the sides
            
            // Apply predicted position to sprite
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y); // Add 200px offset
                updateLocalPlayerHealthBar();
            }
        }
        
        function validateClientJump(currentTime) {
            if (!clientPlayerState || clientPlayerState.health <= 0) return false;
            if (clientPlayerState.jumpsRemaining <= 0) return false;
            if (currentTime - clientPlayerState.lastJumpTime < 200) return false;
            return true;
        }
        
        function performClientJump(currentTime) {
            const jumpVelocity = clientPlayerState.jumpsRemaining === 2 ? 
                PHYSICS_CONSTANTS.JUMP_VELOCITY_SINGLE : 
                PHYSICS_CONSTANTS.JUMP_VELOCITY_DOUBLE;
            
            clientPlayerState.velocityY = jumpVelocity;
            clientPlayerState.jumpsRemaining--;
            clientPlayerState.isGrounded = false;
            clientPlayerState.lastJumpTime = currentTime;
        }
        
        function validateClientDash(currentTime) {
            if (!clientPlayerState || clientPlayerState.health <= 0) return false;
            if (dashInputCooldown > 0) return false; // Prevent multiple dash triggers
            if (clientPlayerState.isDashing) return false; // Prevent dash while already dashing
            if (currentTime - (clientPlayerState.lastDashTime || 0) < 350) return false; // Dash cooldown (reduced from 500)
            return true;
        }

        function performClientDash(direction, currentTime) {
            const dashVelocity = 900; // Match server DASH_VELOCITY (increased from 300)
            const dashDirection = direction === 'left' ? -1 : 1;
            
            // Apply dash physics immediately
            clientPlayerState.isDashing = true;
            clientPlayerState.dashDirection = dashDirection;
            clientPlayerState.dashStartTime = currentTime;
            clientPlayerState.lastDashTime = currentTime;
            clientPlayerState.dashVelocity = dashVelocity * dashDirection;
            
            // Apply immediate velocity boost for responsive feel
            clientPlayerState.velocityX += clientPlayerState.dashVelocity;
            
            // Apply movement immediately  
            const deltaTime = 1 / PHYSICS_CONSTANTS.FRAME_RATE;
            clientPlayerState.x += clientPlayerState.dashVelocity * deltaTime;
            
            // Update sprite position immediately
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                updateLocalPlayerHealthBar();
            }
            
            console.log(`Client predicted dash ${direction} with velocity ${clientPlayerState.dashVelocity}`);
        }
        
        function bufferInput(inputs) {
            // Store input with timestamp for server reconciliation
            inputBuffer.push({
                inputs: { ...inputs },
                timestamp: Date.now(),
                clientState: { ...clientPlayerState }
            });
            
            // Keep buffer size manageable (last 1 second of inputs)
            const oneSecondAgo = Date.now() - 1000;
            inputBuffer = inputBuffer.filter(entry => entry.timestamp > oneSecondAgo);
        }
        
        function reconcileWithServer(serverState) {
            if (!clientPlayerState || !predictionEnabled) return;
            
            const serverPlayer = serverState.players[myPlayerId];
            if (!serverPlayer) return;
            
            // Calculate position difference
            const positionError = Math.sqrt(
                Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                Math.pow(clientPlayerState.y - serverPlayer.y, 2)
            );
            
            // Calculate velocity difference for better correction
            const serverVelX = serverPlayer.velocityX || 0;
            const serverVelY = serverPlayer.velocityY || 0;
            const velocityError = Math.sqrt(
                Math.pow(clientPlayerState.velocityX - serverVelX, 2) + 
                Math.pow(clientPlayerState.velocityY - serverVelY, 2)
            );
            
            // Reduce error threshold for more sensitive corrections
            const errorThreshold = 3; // Reduced from 5px
            const velocityThreshold = 50; // New velocity error threshold
            
            // More aggressive correction for high errors or velocity mismatches
            let correctionFactor = 0.15; // Increased from 0.1
            if (positionError > 15) {
                correctionFactor = 0.3; // Aggressive correction for large errors
            } else if (velocityError > velocityThreshold) {
                correctionFactor = 0.25; // Faster correction for velocity mismatches
            }
            
            // Apply correction if error is significant
            if (positionError > errorThreshold || velocityError > velocityThreshold) {
                // Smooth interpolation towards server position
                clientPlayerState.x += (serverPlayer.x - clientPlayerState.x) * correctionFactor;
                clientPlayerState.y += (serverPlayer.y - clientPlayerState.y) * correctionFactor;
                
                // Always sync velocities to prevent drift
                clientPlayerState.velocityX = serverVelX;
                clientPlayerState.velocityY = serverVelY;
                
                // Sync critical physics state
                clientPlayerState.isGrounded = serverPlayer.isGrounded;
                clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
                
                // Apply corrected position to sprite
                if (playerSprites[myPlayerId]) {
                    playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                    updateLocalPlayerHealthBar();
                }
            }
            
            // Update non-predicted states
            clientPlayerState.health = serverPlayer.health;
            lastServerUpdate = Date.now();
            
            // Update debug panel
            updateDebugPanel();
        }
        
        function updateDebugPanel() {
            document.getElementById('prediction-status').textContent = predictionEnabled ? 'ON' : 'OFF';
            document.getElementById('buffer-size').textContent = inputBuffer.length;
            document.getElementById('last-update').textContent = Date.now() - lastServerUpdate;
            
            if (predictionEnabled && clientPlayerState && gameState.players[myPlayerId]) {
                const serverPlayer = gameState.players[myPlayerId];
                const positionError = Math.sqrt(
                    Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                    Math.pow(clientPlayerState.y - serverPlayer.y, 2)
                );
                
                // Calculate velocity error for debug display
                const serverVelX = serverPlayer.velocityX || 0;
                const serverVelY = serverPlayer.velocityY || 0;
                const velocityError = Math.sqrt(
                    Math.pow(clientPlayerState.velocityX - serverVelX, 2) + 
                    Math.pow(clientPlayerState.velocityY - serverVelY, 2)
                );
                
                document.getElementById('position-error').textContent = positionError.toFixed(1);
                
                // Add velocity error to debug if position error is high
                if (positionError > 10 || velocityError > 20) {
                    document.getElementById('position-error').textContent += ` (vel: ${velocityError.toFixed(1)})`;
                }
            } else {
                document.getElementById('position-error').textContent = '0.0';
            }
        }
        
        function handleJumpEvent(jumpEvent) {
            // Handle jump event for visual effects (particle effects, sound, etc.)
            const playerSprite = playerSprites[jumpEvent.playerId];
            if (!playerSprite) return;
            
            // Visual feedback for jumps
            const jumpEffect = this.add.circle(jumpEvent.position.x + 200, jumpEvent.position.y + 30, 15, 0xFFFF00, 0.7);
            jumpEffect.setDepth(1000); // Render on top
            
            // Animate the effect
            this.tweens.add({
                targets: jumpEffect,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 300,
                ease: 'Power2',
                onComplete: () => {
                    jumpEffect.destroy();
                }
            });
            
            // Different effects for single vs double jump
            if (jumpEvent.jumpType === 'double') {
                // Add sparkle effect for double jump
                const sparkle = this.add.circle(jumpEvent.position.x + 200, jumpEvent.position.y + 25, 8, 0xFF00FF, 0.9);
                sparkle.setDepth(1001);
                
                this.tweens.add({
                    targets: sparkle,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    alpha: 0,
                    duration: 200,
                    ease: 'Power1',
                    onComplete: () => sparkle.destroy()
                });
            }
        }
        
        function handleDashEvent(dashEvent) {
            // Handle dash event for visual effects (particle trail, sound, etc.)
            const playerSprite = playerSprites[dashEvent.playerId];
            if (!playerSprite) return;
            
            // Visual feedback for dash - create trail effect
            const dashTrail = this.add.rectangle(
                dashEvent.position.x + 200, 
                dashEvent.position.y, 
                60, 
                20, 
                0x00FFFF, 
                0.6
            );
            dashTrail.setDepth(999); // Render behind player but above background
            
            // Animate the trail effect
            this.tweens.add({
                targets: dashTrail,
                scaleX: dashEvent.direction === 'left' ? -0.2 : 0.2,
                scaleY: 0.5,
                alpha: 0,
                duration: 200,
                ease: 'Power2',
                onComplete: () => {
                    dashTrail.destroy();
                }
            });
            
            // Add directional speed lines
            for (let i = 0; i < 3; i++) {
                const speedLine = this.add.rectangle(
                    dashEvent.position.x + 200 + (dashEvent.direction === 'left' ? 20 : -20) * (i + 1), // Add 200px offset
                    dashEvent.position.y + (Math.random() - 0.5) * 30,
                    15,
                    3,
                    0xFFFFFF,
                    0.8
                );
                speedLine.setDepth(998);
                
                this.tweens.add({
                    targets: speedLine,
                    x: speedLine.x + (dashEvent.direction === 'left' ? -30 : 30),
                    alpha: 0,
                    duration: 150 + i * 50,
                    ease: 'Linear',
                    onComplete: () => speedLine.destroy()
                });
            }
            
            console.log(`Dash visual effect for player ${dashEvent.playerId} direction ${dashEvent.direction}`);
        }
        
        function handleDashInterruption(interruptEvent) {
            // Handle dash interruption for visual effects cleanup
            const playerSprite = playerSprites[interruptEvent.playerId];
            if (!playerSprite) return;
            
            // Clean up any active dash visual effects
            this.children.getChildren().forEach(child => {
                if (child.name && (child.name.includes('dashTrail') || child.name.includes('speedLine'))) {
                    child.destroy();
                }
            });
            
            // Visual feedback for dash interruption (brief flash effect)
            if (playerSprite) {
                this.tweens.add({
                    targets: playerSprite,
                    alpha: 0.5,
                    duration: 100,
                    yoyo: true,
                    ease: 'Power2'
                });
            }
            
            console.log(`Dash interrupted for player ${interruptEvent.playerId}: ${interruptEvent.reason}`);
        }
        
        function handlePlayerDeath(deathEvent) {
            console.log(`Player ${deathEvent.playerId} died! Lives remaining: ${deathEvent.livesRemaining}`);
            
            // Create death effect at death position
            const deathEffect = this.add.circle(deathEvent.deathPosition.x + 200, deathEvent.deathPosition.y, 50, 0xff0000, 0.8);
            deathEffect.setDepth(1000);
            
            // Animate death effect
            this.tweens.add({
                targets: deathEffect,
                scaleX: 3,
                scaleY: 3,
                alpha: 0,
                duration: 500,
                ease: 'Power2',
                onComplete: () => deathEffect.destroy()
            });
            
            // Handle local player death with countdown and fade effects
            if (deathEvent.playerId === myPlayerId && !deathEvent.isEliminated) {
                // Screen shake for local player death
                this.cameras.main.shake(300, 0.02);
                
                // Start fade effect on player sprite
                if (playerSprites[myPlayerId]) {
                    this.tweens.add({
                        targets: playerSprites[myPlayerId],
                        alpha: 0.2,
                        duration: 3000, // Fade over 3 seconds
                        ease: 'Linear'
                    });
                }
                
                // Start respawn countdown
                startRespawnCountdown();
            }
            
            // For other players, just fade their sprite
            if (deathEvent.playerId !== myPlayerId && playerSprites[deathEvent.playerId]) {
                this.tweens.add({
                    targets: playerSprites[deathEvent.playerId],
                    alpha: 0.3,
                    duration: 1000,
                    ease: 'Power2'
                });
            }
        }
        
        function startRespawnCountdown() {
            const countdownElement = document.getElementById('respawn-countdown');
            let timeLeft = 3;
            
            function updateCountdown() {
                if (timeLeft > 0) {
                    countdownElement.textContent = timeLeft;
                    countdownElement.style.display = 'block';
                    
                    // Pulse effect for countdown
                    countdownElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        countdownElement.style.transform = 'translate(-50%, -50%) scale(1.0)';
                    }, 200);
                    
                    timeLeft--;
                    setTimeout(updateCountdown, 1000);
                } else {
                    countdownElement.style.display = 'none';
                }
            }
            
            updateCountdown();
        }
        
        function handlePlayerRespawn(respawnEvent) {
            console.log(`Player ${respawnEvent.playerId} respawned with invincibility`);
            
            // Restore sprite alpha for respawned player
            if (playerSprites[respawnEvent.playerId]) {
                // Stop any existing fade tweens
                this.tweens.killTweensOf(playerSprites[respawnEvent.playerId]);
                // Restore full alpha
                playerSprites[respawnEvent.playerId].setAlpha(1.0);
            }
            
            // Create respawn effect
            const respawnEffect = this.add.circle(respawnEvent.position.x + 200, respawnEvent.position.y, 30, 0x00ffff, 0.7);
            respawnEffect.setDepth(1000);
            
            // Animate respawn effect
            this.tweens.add({
                targets: respawnEffect,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => respawnEffect.destroy()
            });
            
            // Add sparkle effects
            for (let i = 0; i < 8; i++) {
                const sparkle = this.add.circle(
                    respawnEvent.position.x + 200 + (Math.random() - 0.5) * 60, // Add 200px offset
                    respawnEvent.position.y + (Math.random() - 0.5) * 60,
                    3,
                    0xffffff,
                    0.9
                );
                sparkle.setDepth(1001);
                
                this.tweens.add({
                    targets: sparkle,
                    scaleX: 2,
                    scaleY: 2,
                    alpha: 0,
                    duration: 300 + Math.random() * 200,
                    ease: 'Power1',
                    onComplete: () => sparkle.destroy()
                });
            }
            
            // Hide countdown for local player
            if (respawnEvent.playerId === myPlayerId) {
                const countdownElement = document.getElementById('respawn-countdown');
                countdownElement.style.display = 'none';
            }
        }
        
        function handlePlayerElimination(eliminationEvent) {
            console.log(`Player ${eliminationEvent.playerId} eliminated!`);
            
            // Create elimination effect
            const eliminationEffect = this.add.circle(eliminationEvent.finalPosition.x + 200, eliminationEvent.finalPosition.y, 80, 0xff6600, 0.9);
            eliminationEffect.setDepth(1000);
            
            // Animate elimination effect
            this.tweens.add({
                targets: eliminationEffect,
                scaleX: 4,
                scaleY: 4,
                alpha: 0,
                duration: 800,
                ease: 'Power3',
                onComplete: () => eliminationEffect.destroy()
            });
            
            // Add text effect
            const eliminationText = this.add.text(eliminationEvent.finalPosition.x + 200, eliminationEvent.finalPosition.y - 50, 'ELIMINATED!', {
                fontSize: '24px',
                fill: '#ff6600',
                stroke: '#000000',
                strokeThickness: 2
            });
            eliminationText.setOrigin(0.5);
            eliminationText.setDepth(1001);
            
            this.tweens.add({
                targets: eliminationText,
                y: eliminationText.y - 100,
                alpha: 0,
                duration: 1000,
                ease: 'Power2',
                onComplete: () => eliminationText.destroy()
            });
        }
        
        function handleMatchEnd(matchEndEvent) {
            console.log(`Match ended! Winner: ${matchEndEvent.winnerId}`);
            
            // Create match end overlay
            const overlay = this.add.rectangle(600, 500, 1200, 1000, 0x000000, 0.7); // Expanded to 1200x1000, centered at (600, 500)
            overlay.setDepth(2000);
            
            // Winner text
            const winnerText = matchEndEvent.winnerId === myPlayerId ? 'YOU WIN!' : 
                              matchEndEvent.winnerId ? 'MATCH OVER' : 'DRAW!';
            const winnerColor = matchEndEvent.winnerId === myPlayerId ? '#00ff00' : '#ffffff';
            
            const matchEndText = this.add.text(600, 400, winnerText, { // Centered at 600 for 1200px canvas
                fontSize: '48px',
                fill: winnerColor,
                stroke: '#000000',
                strokeThickness: 3
            });
            matchEndText.setOrigin(0.5);
            matchEndText.setDepth(2001);
            
            // Final standings text
            let standingsText = 'Final Standings:\n';
            matchEndEvent.finalStandings.forEach((standing, index) => {
                const position = index + 1;
                const playerText = standing.playerId === myPlayerId ? 'YOU' : `Player ${standing.playerId.slice(-4)}`;
                standingsText += `${position}. ${playerText} - ${standing.lives} lives\n`;
            });
            
            const standingsDisplay = this.add.text(600, 550, standingsText, { // Centered at 600 for 1200px canvas
                fontSize: '18px',
                fill: '#ffffff',
                align: 'center'
            });
            standingsDisplay.setOrigin(0.5);
            standingsDisplay.setDepth(2001);
            
            // Store overlay elements for cleanup
            this.matchEndOverlay = [overlay, matchEndText, standingsDisplay];
        }
        
        function handleMatchReset(resetEvent) {
            console.log('Match reset - new round starting!');
            
            // Clean up match end overlay
            if (this.matchEndOverlay) {
                this.matchEndOverlay.forEach(element => element.destroy());
                this.matchEndOverlay = null;
            }
            
            // Create new round announcement
            const newRoundText = this.add.text(600, 500, 'NEW ROUND!', { // Centered at 600 for 1200px canvas
                fontSize: '36px',
                fill: '#ffff00',
                stroke: '#000000',
                strokeThickness: 2
            });
            newRoundText.setOrigin(0.5);
            newRoundText.setDepth(1000);
            
            // Animate and remove announcement
            this.tweens.add({
                targets: newRoundText,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 2000,
                ease: 'Power2',
                onComplete: () => newRoundText.destroy()
            });
        }
        
        function handleInvincibilityEnd(invincibilityEvent) {
            console.log(`Player ${invincibilityEvent.playerId} invincibility ended`);
            
            // Visual feedback for invincibility ending (small flash effect)
            if (playerSprites[invincibilityEvent.playerId]) {
                const player = playerSprites[invincibilityEvent.playerId];
                this.tweens.add({
                    targets: player,
                    alpha: 0.3,
                    duration: 100,
                    yoyo: true,
                    repeat: 2,
                    ease: 'Power1'
                });
            }
        }
    </script>
</body>
</html> 