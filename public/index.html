<!DOCTYPE html>
<html>
<head>
    <title>Super Vibe Bros</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="platforms.js"></script>
    
    <!-- Firebase CDN -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            /* Removed border and border-radius for cleaner look */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 1000;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 1000;
        }
        
        /* Bottom Players Panel */
        #players-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            display: none; /* Hidden by default */
            gap: 20px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 1000;
            border: 2px solid rgba(243, 109, 50, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        #players-panel.visible {
            display: flex;
        }
        
        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            min-width: 80px;
        }
        
        .player-name {
            font-weight: bold;
            color: #F36D32;
            font-size: 12px;
            text-align: center;
            max-width: 80px;
            overflow: hidden;
            white-space: nowrap;
            position: relative;
        }
        
        .player-name-text {
            display: inline-block;
            transition: transform 0.1s ease;
        }
        
        .player-name-text.marquee {
            animation: marquee 3s linear infinite;
        }
        
        @keyframes marquee {
            0% { transform: translateX(0); }
            25% { transform: translateX(0); }
            75% { transform: translateX(calc(-100% + 80px)); }
            100% { transform: translateX(calc(-100% + 80px)); }
        }
        
        .player-name.current-player {
            color: #FFD700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }
        
        .player-name.eliminated {
            color: #666;
            text-decoration: line-through;
        }
        
        .player-lives {
            display: flex;
            gap: 2px;
            align-items: center;
        }
        
        .heart-icon {
            width: 16px;
            height: 16px;
            background: url('assets/heart.png') no-repeat center;
            background-size: contain;
        }
        
        .heart-icon.lost {
            opacity: 0.2;
            filter: grayscale(100%);
        }
        #respawn-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ff6666;
            padding: 30px;
            border-radius: 15px;
            font-size: 64px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 2000;
            border: 3px solid #ff6666;
            box-shadow: 0 0 30px rgba(255, 102, 102, 0.5);
        }
        
        /* Game Start Countdown */
        #game-start-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #F36D32;
            padding: 40px;
            border-radius: 20px;
            font-size: 72px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 3000;
            border: 4px solid #F36D32;
            box-shadow: 0 0 40px rgba(243, 109, 50, 0.6);
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        
        #game-start-countdown .countdown-text {
            font-size: 28px;
            margin-bottom: 10px;
            color: #F39C5A;
        }
        
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* Game Over Screen */
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            display: none;
            z-index: 3500;
            border: 3px solid #F36D32;
            box-shadow: 0 0 40px rgba(243, 109, 50, 0.4);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #game-over-screen h1 {
            text-align: center;
            color: #F36D32;
            margin-bottom: 10px;
            font-size: 36px;
        }
        
        #game-over-screen .winner-text {
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            color: #FFD700;
        }
        
        #game-over-screen .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #game-over-screen .stats-table th,
        #game-over-screen .stats-table td {
            padding: 12px 15px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #game-over-screen .stats-table th {
            background: rgba(243, 109, 50, 0.3);
            color: #F36D32;
            font-weight: bold;
        }
        
        #game-over-screen .stats-table tr.winner {
            background: rgba(255, 215, 0, 0.2);
            border-left: 4px solid #FFD700;
        }
        
        #game-over-screen .stats-table tr.current-player {
            background: rgba(243, 109, 50, 0.2);
            border-left: 4px solid #F36D32;
        }
        
        #game-over-screen .stats-table tr.disconnected {
            background: rgba(128, 128, 128, 0.2);
            border-left: 4px solid #888;
            color: #aaa;
            font-style: italic;
        }
        
        #game-over-screen .game-over-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        #game-over-screen .game-over-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        #game-over-screen .rematch-btn {
            background: #F36D32;
            color: white;
        }
        
        #game-over-screen .rematch-btn:hover {
            background: #D85A28;
            transform: translateY(-2px);
        }
        
        #game-over-screen .lobby-btn {
            background: #2196F3;
            color: white;
        }
        
        #game-over-screen .lobby-btn:hover {
            background: #1976D2;
            transform: translateY(-2px);
        }
        
        #game-over-screen .rematch-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Room Management UI Styles */
        #room-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 1500;
            border: 2px solid #F36D32;
            box-shadow: 0 0 30px rgba(243, 109, 50, 0.3);
            font-family: Arial, sans-serif;
            min-width: 400px;
        }
        
        #room-ui h1 {
            margin: 0 0 30px 0;
            color: #F36D32;
            font-size: 36px;
            text-shadow: 0 0 10px rgba(243, 109, 50, 0.5);
        }
        
        #room-ui h2 {
            margin: 20px 0 15px 0;
            color: #ffffff;
            font-size: 24px;
        }
        
        .room-section {
            margin: 16px 0;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            text-align: center;
        }
        
        .room-button {
            background: #F36D32;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: auto;
            margin-bottom: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            display: inline-block;
        }
        
        .room-button:hover {
            background: #D85A28;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .room-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .room-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #F36D32;
            color: white;
            padding: 12px 20px;
            font-size: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 10px;
            width: 120px;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        
        .room-input:focus {
            outline: none;
            border-color: #F39C5A;
            box-shadow: 0 0 10px rgba(243, 109, 50, 0.5);
        }
        
        #room-code-display {
            font-size: 36px;
            font-weight: bold;
            color: #F36D32;
            background: rgba(243, 109, 50, 0.1);
            padding: 20px;
            border-radius: 15px;
            letter-spacing: 8px;
            text-shadow: 0 0 15px rgba(243, 109, 50, 0.7);
            border: 2px solid #F36D32;
            margin: 20px 0;
        }
        
        #player-list {
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .player-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .player-host {
            background: rgba(243, 109, 50, 0.2);
            border-left: 4px solid #F36D32;
        }
        
        .error-message {
            color: #f44336;
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid #f44336;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .warning-message {
            color: #F36D32;
            background: rgba(243, 109, 50, 0.1);
            border: 1px solid #F36D32;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from { box-shadow: 0 0 5px rgba(243, 109, 50, 0.5); }
            to { box-shadow: 0 0 20px rgba(243, 109, 50, 0.8); }
        }
        
        .success-message {
            color: #F36D32;
            background: rgba(243, 109, 50, 0.1);
            border: 1px solid #F36D32;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        #room-ui.hidden {
            display: none;
        }

        /* Disconnection Countdown Toast */
        .disconnect-toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #F36D32;
            color: #ffffff;
            padding: 30px 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 4000;
            border: 3px solid #D85A28;
            box-shadow: 0 0 40px rgba(243, 109, 50, 0.6);
            display: none;
            width: 500px;
        }

        .disconnect-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .disconnect-message {
            font-size: 16px;
            margin-bottom: 15px;
        }

        .disconnect-timer {
            font-size: 64px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .disconnect-subtext {
            font-size: 14px;
        }

    </style>
</head>
<body>
    <div id="ui">
        <div id="player-count">Players: 0</div>
        <div id="match-status"></div>
    </div>
    
    <!-- Bottom Players Panel -->
    <div id="players-panel">
        <!-- Players will be populated here dynamically -->
    </div>
    
    <!-- Room Management UI -->
    <div id="room-ui">
        <img src="assets/supervibebros-pixel.png" alt="Super Vibe Bros" style="height: 160px; vertical-align: middle;">
        
        <!-- Authentication Section -->
        <div id="auth-section">
            <div class="room-section">
                <h3>How would you like to play?</h3>
                
                <!-- Guest Play Option -->
                <div class="auth-option">
                    <h3 style="color: #F36D32; margin: 10px 0;">🎮 Play as Guest</h3>
                    <p style="color: #aaa; font-size: 14px; margin: 10px 0;">Jump right in! No account needed.</p>
                    <input type="text" id="guest-name-input" class="room-input" placeholder="Your Name" maxlength="20" style="width: 200px; margin: 10px;" />
                    <br>
                    <button id="guest-play-btn" class="room-button">Start Playing</button>
                </div>
                
                <div style="margin: 20px 0; color: #666;">- OR -</div>
                
                <!-- Registered User Options -->
                <div class="auth-option">
                    <h3 style="color: #2196F3; margin: 10px 0;">👤 Account Login</h3>
                    <p style="color: #aaa; font-size: 14px; margin: 10px 0;">Save your progress and stats!</p>
                    <button id="show-login-btn" class="room-button" style="background: #2196F3;">Login</button>
                    <button id="show-register-btn" class="room-button" style="background: #FF9800; margin-left: 10px;">Register</button>
                </div>
            </div>
        </div>
        
        <!-- Login Form -->
        <div id="login-form" style="display: none;">
            <div class="room-section">
                <h2>Login to Your Account</h2>
                <input type="email" id="login-email" class="room-input" placeholder="Email" style="width: 250px; margin: 5px;" />
                <br>
                <input type="password" id="login-password" class="room-input" placeholder="Password" style="width: 250px; margin: 5px;" />
                <br>
                <button id="login-submit-btn" class="room-button" style="background: #2196F3;">Login</button>
                <button id="back-to-auth-btn" class="room-button" style="background: #666; margin-left: 10px;">Back</button>
            </div>
        </div>
        
        <!-- Register Form -->
        <div id="register-form" style="display: none;">
            <div class="room-section">
                <h2>Create New Account</h2>
                <input type="text" id="register-username" class="room-input" placeholder="Username" style="width: 250px; margin: 5px;" />
                <br>
                <input type="email" id="register-email" class="room-input" placeholder="Email" style="width: 250px; margin: 5px;" />
                <br>
                <input type="password" id="register-password" class="room-input" placeholder="Password" style="width: 250px; margin: 5px;" />
                <br>
                <button id="register-submit-btn" class="room-button" style="background: #FF9800;">Create Account</button>
                <button id="back-to-auth-btn2" class="room-button" style="background: #666; margin-left: 10px;">Back</button>
            </div>
        </div>
        
        <!-- Main Menu (when authenticated and not in room) -->
        <div id="main-menu" style="display: none;">
            <div id="authenticated-user-info" style="color: #F36D32; margin-bottom: 20px; font-size: 14px;">
                <!-- User info will be populated here -->
            </div>
            
            <div class="room-section">
                <h2>Create a New Game</h2>
                <button id="create-room-btn" class="room-button">Create Room</button>
                <p style="color: #aaa; font-size: 14px;">Share the room code with friends!</p>
            </div>
            
            <div class="room-section">
                <h2>Join a Game</h2>
                <input type="text" id="room-code-input" class="room-input" placeholder="ROOM" maxlength="4" />
                <br>
                <button id="join-room-btn" class="room-button">Join Room</button>
            </div>
        </div>
        
        <!-- Room Lobby (when in room) -->
        <div id="room-lobby" style="display: none;">
            <h2>Room Code</h2>
            <div id="room-code-display">ABCD</div>
            <p style="color: #aaa;">Share this code with your friends!</p>
            
            <div class="room-section">
                <h2>Players (<span id="room-player-count">1</span>/8)</h2>
                <div id="player-list">
                    <!-- Players will be added here dynamically -->
                </div>
            </div>
            
            <!-- <div class="room-section"> -->
                <button id="start-game-btn" class="room-button" style="display: none;">Start Game</button>
                <button id="leave-room-btn" class="room-button" style="background: #f44336;">Leave Room</button>
            <!-- </div> -->
        </div>
        
        <!-- Messages -->
        <div id="room-messages"></div>
    </div>
    
    <div id="game-container"></div>
    <div id="respawn-countdown"></div>
    
    <!-- Disconnection Countdown Toast -->
    <div id="disconnect-countdown" class="disconnect-toast">
        <div class="disconnect-title">⚠️ PLAYER DISCONNECTED</div>
        <div id="disconnect-message" class="disconnect-message">Waiting for reconnection...</div>
        <div id="disconnect-timer" class="disconnect-timer">10</div>
        <div class="disconnect-subtext">seconds to rejoin or you win!</div>
    </div>
    
    <!-- Game Start Countdown -->
    <div id="game-start-countdown">
        <div class="countdown-text">Game Starting...</div>
        <div class="countdown-number">3</div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <h1>🏆 Game Over! 🏆</h1>
        <div class="winner-text" id="winner-text">Winner: Player ABC...</div>
        
        <table class="stats-table" id="stats-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Player</th>
                    <th>Kills</th>
                    <th>Deaths</th>
                    <th>K/D</th>
                </tr>
            </thead>
            <tbody id="stats-tbody">
                <!-- Stats will be populated here -->
            </tbody>
        </table>
        
        <div class="game-over-buttons">
            <button id="rematch-btn" class="game-over-btn rematch-btn">Rematch</button>
            <button id="return-lobby-btn" class="game-over-btn lobby-btn">Return to Lobby</button>
        </div>
    </div>
    
    <div id="controls">
        <div>Controls:</div>
        <div>Left/Right: Move</div>
        <div>Up: Jump</div>
        <div>Down: Drop through platforms</div>
        <div>Space: Attack</div>
        <div>Z: Block</div>
        <div>Shift+Arrow: Dash</div>
        <div>Double-tap Arrow: Dash</div>
        <div>P: Toggle Prediction</div>
        <div>R: Force Resync (debug)</div>
    </div>
    
    <div id="prediction-debug" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; display: none;">
        <div>Prediction: <span id="prediction-status">OFF</span></div>
                        <div>Position Error: <span id="position-error">0.0</span>px <span id="correction-status"></span></div>
        <div>Buffer Size: <span id="buffer-size">0</span></div>
        <div>Last Update: <span id="server-time">0</span>ms ago</div>
        <div>Input Status: <span id="input-status">Normal</span></div>
        <div>Latency: <span id="latency">0ms</span></div>
        <div>Server Tick: <span id="server-tickrate">30fps</span></div>
    </div>
    
    <script>
        // ==================== FIREBASE AUTHENTICATION ====================
        
        // Firebase configuration - Real config from Firebase CLI
        const firebaseConfig = {
            apiKey: "AIzaSyAh2m1SciisBB6EDxmShQJyxW1uAp0Z32I",
            authDomain: "fighter-game-multiplayer.firebaseapp.com", 
            projectId: "fighter-game-multiplayer",
            storageBucket: "fighter-game-multiplayer.firebasestorage.app",
            messagingSenderId: "799099672774",
            appId: "1:799099672774:web:8e080095ca01c28a1cdfc7"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        
        // Authentication state management
        let currentUser = null;
        let authToken = null;
        
        // Authentication UI elements
        const authSection = document.getElementById('auth-section');
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        
        // Room management variables (moved up to avoid initialization errors)
        let currentRoom = null;
        let isHost = false;
        let gameStarted = false;
        
        // Room UI Elements (moved up to avoid initialization errors)
        const roomUI = document.getElementById('room-ui');
        const mainMenu = document.getElementById('main-menu');
        const roomLobby = document.getElementById('room-lobby');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const roomCodeInput = document.getElementById('room-code-input');
        const roomCodeDisplay = document.getElementById('room-code-display');
        const playerList = document.getElementById('player-list');
        const playerCount = document.getElementById('room-player-count');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const roomMessages = document.getElementById('room-messages');
        
        // Game Over UI Elements (moved up to avoid initialization errors)
        const gameOverScreen = document.getElementById('game-over-screen');
        const winnerText = document.getElementById('winner-text');
        const statsTable = document.getElementById('stats-table');
        const statsTbody = document.getElementById('stats-tbody');
        const rematchBtn = document.getElementById('rematch-btn');
        const returnLobbyBtn = document.getElementById('return-lobby-btn');
        
        // Authentication event handlers
        document.addEventListener('DOMContentLoaded', () => {
            setupAuthEventListeners();
            // Ensure clean initial state - show only authentication section
            showAuthSection();
        });
        
        function setupAuthEventListeners() {
            // Guest play
            document.getElementById('guest-play-btn').addEventListener('click', handleGuestPlay);
            
            // Show login/register forms
            document.getElementById('show-login-btn').addEventListener('click', () => showAuthForm('login'));
            document.getElementById('show-register-btn').addEventListener('click', () => showAuthForm('register'));
            
            // Back buttons
            document.getElementById('back-to-auth-btn').addEventListener('click', showAuthSection);
            document.getElementById('back-to-auth-btn2').addEventListener('click', showAuthSection);
            
            // Form submissions
            document.getElementById('login-submit-btn').addEventListener('click', handleLogin);
            document.getElementById('register-submit-btn').addEventListener('click', handleRegister);
            
            // Enter key handlers
            document.getElementById('guest-name-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleGuestPlay();
            });
            document.getElementById('login-password').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleLogin();
            });
            document.getElementById('register-password').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleRegister();
            });
        }
        
        function showAuthSection() {
            console.log('showAuthSection called - showing authentication UI');
            
            // Show authentication section
            if (authSection) {
                authSection.style.setProperty('display', 'block', 'important');
                authSection.style.setProperty('visibility', 'visible', 'important');
                authSection.style.setProperty('opacity', '1', 'important');
                
                // Restore visibility of child elements
                const authChildren = authSection.querySelectorAll('*');
                authChildren.forEach(child => {
                    child.style.removeProperty('display');
                });
                console.log('Showed auth-section and restored', authChildren.length, 'children');
            }
            
            // Hide all other sections
            if (loginForm) {
                loginForm.style.setProperty('display', 'none', 'important');
            }
            if (registerForm) {
                registerForm.style.setProperty('display', 'none', 'important');
            }
            
            // Hide main menu and room lobby
            const mainMenuEl = document.getElementById('main-menu');
            const roomLobbyEl = document.getElementById('room-lobby');
            if (mainMenuEl) {
                mainMenuEl.style.setProperty('display', 'none', 'important');
            }
            if (roomLobbyEl) {
                roomLobbyEl.style.setProperty('display', 'none', 'important');
            }
            
            // Show room UI container but only with auth section
            roomUI.classList.remove('hidden');
            
            // Hide players panel when in authentication
            const playersPanel = document.getElementById('players-panel');
            if (playersPanel) {
                playersPanel.classList.remove('visible');
            }
            
            console.log('showAuthSection complete - only auth section should be visible');
        }
        
        function showAuthForm(type) {
            authSection.style.setProperty('display', 'none', 'important');
            loginForm.style.setProperty('display', type === 'login' ? 'block' : 'none', 'important');
            registerForm.style.setProperty('display', type === 'register' ? 'block' : 'none', 'important');
            
            // Hide main menu properly
            const mainMenuEl = document.getElementById('main-menu');
            if (mainMenuEl) mainMenuEl.style.setProperty('display', 'none', 'important');
            
            // Get roomLobby safely
            const roomLobby = document.getElementById('room-lobby');
            if (roomLobby) roomLobby.style.setProperty('display', 'none', 'important');
            console.log('Showing auth form:', type);
        }
        
        function showMainMenu() {
            console.log('showMainMenu called - transitioning to main menu');
            
            // Hide all authentication UI components completely
            if (authSection) {
                authSection.style.setProperty('display', 'none', 'important');
                authSection.style.setProperty('visibility', 'hidden', 'important');
                authSection.style.setProperty('opacity', '0', 'important');
                console.log('Hidden auth-section');
            }
            if (loginForm) {
                loginForm.style.setProperty('display', 'none', 'important');
                console.log('Hidden login-form');
            }
            if (registerForm) {
                registerForm.style.setProperty('display', 'none', 'important');
                console.log('Hidden register-form');
            }
            
            // Show main menu and hide room lobby
            const mainMenuElement = document.getElementById('main-menu');
            const roomLobby = document.getElementById('room-lobby');
            
            if (mainMenuElement) {
                mainMenuElement.style.setProperty('display', 'block', 'important');
                console.log('Showed main-menu');
            }
            if (roomLobby) {
                roomLobby.style.setProperty('display', 'none', 'important');
                console.log('Hidden room-lobby');
            }
            
            // Show room UI container and hide players panel
            roomUI.classList.remove('hidden');
            gameStarted = false;
            
            // Hide players panel when in menu
            const playersPanel = document.getElementById('players-panel');
            if (playersPanel) {
                playersPanel.classList.remove('visible');
            }
            
            console.log('showMainMenu complete - should show main menu only');
        }
        

        
        // Guest authentication
        async function handleGuestPlay() {
            const displayName = document.getElementById('guest-name-input').value.trim();
            
            if (!displayName || displayName.length < 2) {
                showMessage('Please enter a name (at least 2 characters)', 'error');
                return;
            }
            
            try {
                // Sign in anonymously with Firebase
                const userCredential = await auth.signInAnonymously();
                const user = userCredential.user;
                
                // Update profile with display name
                await user.updateProfile({ displayName: displayName });
                
                // Store guest user data
                await db.collection('users').doc(user.uid).set({
                    displayName: displayName,
                    isGuest: true,
                    isAnonymous: true,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0
                });
                
                // Store in localStorage
                localStorage.setItem('guestDisplayName', displayName);
                localStorage.setItem('guestUserId', user.uid);
                
                currentUser = {
                    uid: user.uid,
                    displayName: displayName,
                    isGuest: true,
                    isAnonymous: true
                };
                
                // Get Firebase ID token for server authentication
                authToken = await user.getIdToken();
                
                console.log('Guest authentication successful:', user.uid);
                showMessage(`Welcome ${displayName}! Playing as guest.`, 'success');
                updateUserInfo(displayName, true);
                
                // Reconnect socket with auth token
                await reconnectSocketWithAuth();
                
                showMainMenu();
                
            } catch (error) {
                console.error('Guest authentication error:', error);
                showMessage('Failed to start guest session: ' + error.message, 'error');
            }
        }
        
        // Login with email/password
        async function handleLogin() {
            const email = document.getElementById('login-email').value.trim();
            const password = document.getElementById('login-password').value;
            
            if (!email || !password) {
                showMessage('Please enter both email and password', 'error');
                return;
            }
            
            try {
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                const user = userCredential.user;
                
                // Update last active timestamp
                await db.collection('users').doc(user.uid).update({
                    lastActive: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                currentUser = {
                    uid: user.uid,
                    email: user.email,
                    displayName: user.displayName,
                    isGuest: false,
                    isAnonymous: false
                };
                
                // Get Firebase ID token for server authentication
                authToken = await user.getIdToken();
                
                console.log('Login successful:', user.uid);
                showMessage(`Welcome back ${user.displayName}!`, 'success');
                updateUserInfo(user.displayName || user.email, false);
                
                // Reconnect socket with auth token
                await reconnectSocketWithAuth();
                
                showMainMenu();
                
            } catch (error) {
                console.error('Login error:', error);
                showMessage('Login failed: ' + error.message, 'error');
            }
        }
        
        // Register new user
        async function handleRegister() {
            const username = document.getElementById('register-username').value.trim();
            const email = document.getElementById('register-email').value.trim();
            const password = document.getElementById('register-password').value;
            
            if (!username || !email || !password) {
                showMessage('Please fill in all fields', 'error');
                return;
            }
            
            if (username.length < 3 || username.length > 20) {
                showMessage('Username must be 3-20 characters', 'error');
                return;
            }
            
            try {
                console.log('Starting registration process...');
                
                // Check if username is available
                console.log('Checking username availability...');
                const usernameDoc = await db.collection('usernames').doc(username.toLowerCase()).get();
                if (usernameDoc.exists) {
                    showMessage('Username already taken', 'error');
                    return;
                }
                console.log('Username available, proceeding...');
                
                console.log('Creating Firebase Auth user...');
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;
                console.log('Firebase Auth user created:', user.uid);
                
                // Update profile with username
                console.log('Updating user profile...');
                await user.updateProfile({ displayName: username });
                console.log('Profile updated successfully');
                
                // Ensure user is fully authenticated and get fresh token
                console.log('Getting fresh auth token...');
                const freshToken = await user.getIdToken(true); // Force refresh
                console.log('Fresh token obtained, user fully authenticated');
                
                // Small delay to ensure auth state propagation
                await new Promise(resolve => setTimeout(resolve, 100));
                console.log('Auth state propagation delay complete');
                
                // Store user data
                console.log('Storing user data in Firestore...');
                await db.collection('users').doc(user.uid).set({
                    username: username,
                    email: email,
                    displayName: username,
                    isGuest: false,
                    isAnonymous: false,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0,
                    level: 1,
                    xp: 0
                });
                console.log('User data stored successfully');
                
                // Reserve username
                console.log('Reserving username in Firestore...');
                await db.collection('usernames').doc(username.toLowerCase()).set({
                    uid: user.uid,
                    username: username,
                    reservedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log('Username reserved successfully');
                
                currentUser = {
                    uid: user.uid,
                    email: user.email,
                    displayName: username,
                    isGuest: false,
                    isAnonymous: false
                };
                
                // Get Firebase ID token for server authentication
                authToken = await user.getIdToken();
                
                console.log('Registration successful:', user.uid);
                showMessage(`Welcome ${username}! Account created successfully.`, 'success');
                updateUserInfo(username, false);
                
                // Reconnect socket with auth token
                await reconnectSocketWithAuth();
                
                showMainMenu();
                
            } catch (error) {
                console.error('Registration error:', error);
                showMessage('Registration failed: ' + error.message, 'error');
            }
        }
        
        // Send auth token to server after authentication
        async function reconnectSocketWithAuth() {
            if (!authToken) {
                console.log('No auth token available');
                return;
            }
            
            if (!socket || !socket.connected) {
                console.log('Socket not connected, waiting...');
                return;
            }
            
            console.log('Sending auth token to server...');
            
            // Send auth token to server for authentication
            socket.emit('authenticate', { token: authToken }, (response) => {
                if (response && response.success) {
                    console.log('Server authentication successful:', response.user);
                } else {
                    console.error('Server authentication failed:', response?.error || 'Unknown error');
                }
            });
        }
        
        // Send authentication to server (synchronous version for room operations)
        async function sendAuthToServer() {
            if (!authToken) {
                console.log('No auth token available');
                return false;
            }
            
            if (!socket || !socket.connected) {
                console.log('Socket not connected');
                return false;
            }
            
            return new Promise((resolve) => {
                console.log('Sending auth token to server...');
                socket.emit('authenticate', { token: authToken }, (response) => {
                    if (response && response.success) {
                        console.log('Authentication successful with server');
                        resolve(true);
                    } else {
                        console.error('Authentication failed with server:', response?.error);
                        resolve(false);
                    }
                });
            });
        }
        
        // Utility functions for user info and sign-out
        function updateUserInfo(displayName, isGuest) {
            const userInfoDiv = document.getElementById('authenticated-user-info');
            if (userInfoDiv) {
                const userType = isGuest ? 'Guest Player' : 'Registered Player';
                const icon = isGuest ? '🎮' : '👤';
                userInfoDiv.innerHTML = `
                    ${icon} ${userType}: <strong>${displayName}</strong><br>
                    <a href="#" id="sign-out-link" style="color: #888; text-decoration: underline; font-size: 12px; cursor: pointer;">sign out</a>
                `;
                
                // Re-attach event listener to the new sign-out link
                const signOutLink = document.getElementById('sign-out-link');
                if (signOutLink) {
                    signOutLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        handleSignOut();
                    });
                }
            }
        }
        
        async function handleSignOut() {
            try {
                await auth.signOut();
                currentUser = null;
                authToken = null;
                
                // Clear localStorage
                localStorage.removeItem('guestDisplayName');
                localStorage.removeItem('guestUserId');
                
                showMessage('Signed out successfully', 'success');
                
                // Clear user info first
                const userInfoDiv = document.getElementById('authenticated-user-info');
                if (userInfoDiv) {
                    userInfoDiv.innerHTML = '';
                }
                
                showAuthSection();
                
            } catch (error) {
                console.error('Sign out error:', error);
                showMessage('Failed to sign out: ' + error.message, 'error');
            }
        }
        
        // Listen for auth state changes
        auth.onAuthStateChanged((user) => {
            if (user && !currentUser) {
                // User is signed in but we haven't set currentUser yet
                // This happens on page refresh
                console.log('User found on auth state change:', user.uid);
                
                currentUser = {
                    uid: user.uid,
                    email: user.email,
                    displayName: user.displayName,
                    isGuest: user.isAnonymous,
                    isAnonymous: user.isAnonymous
                };
                
                if (user.isAnonymous) {
                    const savedName = localStorage.getItem('guestDisplayName');
                    if (savedName) {
                        currentUser.displayName = savedName;
                    }
                }
                
                user.getIdToken().then(token => {
                    authToken = token;
                });
                
                // Update user info before showing main menu
                const displayName = currentUser.displayName || currentUser.email || 'User';
                updateUserInfo(displayName, currentUser.isGuest);
                showMainMenu();
            } else if (!user && currentUser) {
                // User signed out
                currentUser = null;
                authToken = null;
                showAuthSection();
            }
        });
        
        // ==================== END FIREBASE AUTHENTICATION ====================

        // Phaser game configuration
        const config = {
            type: Phaser.AUTO,
            width: 1200, // Expanded from 800 to allow fall-off movement
            height: 1000, // Expanded from 600 to allow fall recovery attempts
            parent: 'game-container',
            backgroundColor: '#3d2a1f',
            fps: {
                target: 30,
                forceSetTimeOut: true
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 }, // Server handles gravity
                    debug: false // Server handles collision detection
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // Create the game
        const game = new Phaser.Game(config);

        let cursors;
        let socket;
        let spaceKey;
        let zKey;
        let shiftKey; // Dedicated dash key
        let platforms; // Platform physics group
        
        // Dash input detection variables
        let lastLeftKeyTime = 0;
        let lastRightKeyTime = 0;
        let dashInputCooldown = 0; // Prevent multiple dash triggers
        const DASH_DOUBLE_TAP_WINDOW = 250; // ms
        const DASH_INPUT_COOLDOWN = 100; // ms to prevent multiple triggers
        
        const playerSprites = {};
        const playerHealthBars = {};
        const playerAttackEffects = {};
        let myPlayerId = null;
        let gameState = { players: {} };
        
        // Client-side prediction variables
        let clientPlayerState = null;
        let inputBuffer = [];
        let lastServerUpdate = 0;
        let predictionEnabled = false;
        
        // Log initial physics configuration
        console.log(`[CLIENT PHYSICS] Started with 30fps (deltaTime: ${(1/30).toFixed(4)}s) to match server tick rate`);
        const PHYSICS_CONSTANTS = {
            GRAVITY: 1200, // Increased for snappier falls
            GROUND_Y: 524, // Updated to match platform Y=580, height=32, player height=80
            FRAME_RATE: 30, // Match server tick rate for consistency
            JUMP_VELOCITY_SINGLE: -550, // Slightly stronger jumps
            JUMP_VELOCITY_DOUBLE: -450
        };

        // ==================== ROOM MANAGEMENT SYSTEM ====================
        

        
        // Room management functions
        function showMessage(message, type = 'info', duration = 5000) {
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 
                                  type === 'warning' ? 'warning-message' : 'success-message';
            messageDiv.textContent = message;
            roomMessages.appendChild(messageDiv);
            
            // Auto-remove message after specified duration
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, duration);
        }
        
        // showMainMenu function is now consolidated in the auth section above
        
        function showRoomLobby(roomCode, hostStatus) {
            // Hide all authentication sections completely
            const authSectionEl = document.getElementById('auth-section');
            const loginFormEl = document.getElementById('login-form');
            const registerFormEl = document.getElementById('register-form');
            const mainMenuEl = document.getElementById('main-menu');
            const roomLobbyEl = document.getElementById('room-lobby');
            
            if (authSectionEl) authSectionEl.style.setProperty('display', 'none', 'important');
            if (loginFormEl) loginFormEl.style.setProperty('display', 'none', 'important');
            if (registerFormEl) registerFormEl.style.setProperty('display', 'none', 'important');
            
            // Hide main menu and show room lobby
            if (mainMenuEl) mainMenuEl.style.setProperty('display', 'none', 'important');
            if (roomLobbyEl) roomLobbyEl.style.setProperty('display', 'block', 'important');
            
            roomCodeDisplay.textContent = roomCode;
            isHost = hostStatus;
            
            // Show start button only for host
            startGameBtn.style.display = isHost ? 'block' : 'none';
            
            // Hide players panel when in lobby
            const playersPanel = document.getElementById('players-panel');
            if (playersPanel) {
                playersPanel.classList.remove('visible');
            }
            
            console.log('Showing room lobby for room:', roomCode);
        }
        
        function hideRoomUI() {
            roomUI.classList.add('hidden');
            gameStarted = true;
            // Show players panel during gameplay
            const playersPanel = document.getElementById('players-panel');
            if (playersPanel) {
                playersPanel.classList.add('visible');
            }
        }
        
        function updatePlayerList(players) {
            playerList.innerHTML = '';
            
            if (players && players.length > 0) {
                players.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-item';
                    if (player.isHost) {
                        playerDiv.classList.add('player-host');
                    }
                    
                    const playerId = player.socketId || player.id;
                    playerDiv.innerHTML = `
                        <span>${player.name || `Player ${playerId.substring(0, 8)}...`}</span>
                        <span>${player.isHost ? '👑 Host' : '🕹️ Player'}</span>
                    `;
                    
                    playerList.appendChild(playerDiv);
                });
                
                playerCount.textContent = players.length;
            } else {
                playerCount.textContent = '0';
            }
        }
        
        async function createRoom() {
            if (!socket) {
                showMessage('Not connected to server', 'error');
                return;
            }
            
            // Ensure authentication before creating room
            if (authToken) {
                console.log('Ensuring authentication before creating room...');
                await sendAuthToServer();
            }
            
            createRoomBtn.disabled = true;
            createRoomBtn.textContent = 'Creating...';
            
            socket.emit('createRoom', (response) => {
                createRoomBtn.disabled = false;
                createRoomBtn.textContent = 'Create Room';
                
                if (response.success) {
                    currentRoom = {
                        code: response.roomCode,
                        isHost: response.isHost,
                        playerCount: response.playerCount
                    };
                    
                    showRoomLobby(response.roomCode, response.isHost);
                    showMessage(`Room ${response.roomCode} created successfully!`, 'success');
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        async function joinRoom() {
            const roomCode = roomCodeInput.value.trim().toUpperCase();
            
            if (!roomCode || roomCode.length !== 4) {
                showMessage('Please enter a 4-letter room code', 'error');
                return;
            }
            
            if (!socket) {
                showMessage('Not connected to server', 'error');
                return;
            }
            
            // Ensure authentication before joining room
            if (authToken) {
                console.log('Ensuring authentication before joining room...');
                await sendAuthToServer();
            }
            
            joinRoomBtn.disabled = true;
            joinRoomBtn.textContent = 'Joining...';
            
            socket.emit('joinRoom', { roomCode }, (response) => {
                joinRoomBtn.disabled = false;
                joinRoomBtn.textContent = 'Join Room';
                
                if (response.success) {
                    currentRoom = {
                        code: response.roomCode,
                        isHost: response.isHost,
                        playerCount: response.playerCount
                    };
                    
                    showRoomLobby(response.roomCode, response.isHost);
                    showMessage(`Joined room ${response.roomCode}!`, 'success');
                    roomCodeInput.value = '';
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        function leaveRoom() {
            if (!socket || !currentRoom) return;
            
            socket.emit('leaveRoom', (response) => {
                if (response.success) {
                    currentRoom = null;
                    isHost = false;
                    if (window.gameScene) {
                        window.gameScene.hideDisconnectionCountdown();
                    }
                    showMainMenu();
                    showMessage('Left room successfully', 'success');
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        function startGame() {
            if (!isHost) {
                showMessage('Only the host can start the game', 'error');
                return;
            }
            
            // Disable the start button to prevent multiple clicks
            startGameBtn.disabled = true;
            startGameBtn.textContent = 'Starting...';
            
            // Emit startGame event to server
            socket.emit('startGame', (response) => {
                if (response.success) {
                    // Game start countdown will be handled by socket events
                    console.log('Game start initiated:', response.message);
                } else {
                    showMessage(response.error, 'error');
                    // Re-enable the button if there was an error
                    startGameBtn.disabled = false;
                    startGameBtn.textContent = 'Start Game';
                }
            });
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            createRoomBtn.addEventListener('click', createRoom);
            joinRoomBtn.addEventListener('click', joinRoom);
            leaveRoomBtn.addEventListener('click', leaveRoom);
            startGameBtn.addEventListener('click', startGame);
            
            // Game Over button event listeners
            rematchBtn.addEventListener('click', handleRematch);
            returnLobbyBtn.addEventListener('click', handleReturnToLobby);
            
            // Handle Enter key in room code input
            roomCodeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    joinRoom();
                }
            });
            
            // Auto-uppercase room code input
            roomCodeInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase();
            });
        });
        


        // ==================== END ROOM MANAGEMENT SYSTEM ====================

        // Character and asset configuration
        const SPRITE_CONFIG = {
            IDLE: { frames: 10, width: 96, height: 96, frameRate: 8 },
            RUN: { frames: 12, width: 96, height: 96, frameRate: 12 },
            JUMP: { frames: 3, width: 96, height: 96, frameRate: 6 },
            BLOCK: { frames: 5, width: 96, height: 96, frameRate: 6 },
            'ATTACK 1': { frames: 12, width: 96, height: 96, frameRate: 15 },
            'ATTACK 2': { frames: 14, width: 96, height: 96, frameRate: 15 },
            HURT: { frames: 11, width: 96, height: 96, frameRate: 10 },
            DEATH: { frames: 21, width: 96, height: 96, frameRate: 12 }
        };

        // Available characters (used for asset loading)
        const SAMURAI_CHARACTERS = ['samurai-1', 'samurai-4'];

        // Character-specific Y offsets to compensate for different artwork baselines
        const CHARACTER_Y_OFFSETS = {
            'samurai-1': 0,    // Baseline character
            'samurai-4': 8     // Bring samurai-4 down 8px to align with ground
        };

        // Store player character assignments (from server)
        const playerCharacters = {};

        function preload() {
            // Load background asset
            this.load.image('background', 'assets/Environment/Background/bkg.png');
            
            // Load tileset and use spritesheet approach with multiple configurations
            // Load full tileset image
            this.load.image('tileset-full', 'assets/Environment/Tileset/Tileset.png');
            
            // Load 32x32 tiles as spritesheet
            this.load.spritesheet('tileset-32', 'assets/Environment/Tileset/Tileset.png', {
                frameWidth: 32,
                frameHeight: 32
            });
            
            // Load 96x96 tiles as spritesheet with manual offset calculation
            this.load.spritesheet('tileset-96', 'assets/Environment/Tileset/Tileset.png', {
                frameWidth: 96,
                frameHeight: 96,
                spacing: 0,
                margin: 0
            });
            
            // Alternative: Load the tileset as a regular image for manual cropping if needed
            this.load.image('tileset-full-debug', 'assets/Environment/Tileset/Tileset.png');
            
            // Load 32x96 vertical tiles as spritesheet  
            this.load.spritesheet('tileset-32x96', 'assets/Environment/Tileset/Tileset.png', {
                frameWidth: 32,
                frameHeight: 96
            });
            
            // Load Flag.png for one-way platforms
            this.load.image('flag', 'assets/Environment/Props/Flag.png');

            // Load all samurai character spritesheets
            SAMURAI_CHARACTERS.forEach(character => {
                Object.keys(SPRITE_CONFIG).forEach(action => {
                    const config = SPRITE_CONFIG[action];
                    this.load.spritesheet(`${character}-${action.toLowerCase().replace(' ', '-')}`, 
                        `assets/${character}/${action}.png`, {
                            frameWidth: config.width,
                            frameHeight: config.height
                        });
                });
            });

            console.log('[SPRITES] Loading character spritesheets for', SAMURAI_CHARACTERS.length, 'characters');
            console.log('[SPRITES] Loading tileset spritesheet for platform tiling');
            
            // Debug: Log tileset frame info after loading
            this.load.on('complete', () => {
                const tilesetTexture = this.textures.get('tileset-96');
                if (tilesetTexture) {
                    console.log('[TILESET DEBUG] Total frames in tileset-96:', tilesetTexture.frameTotal);
                    console.log('[TILESET DEBUG] Frame data:', tilesetTexture.frames);
                }
            });
        }

        // Platforms are now server-side only - no client collision callbacks needed

        function create() {
            // Add background
            const background = this.add.image(600, 500, 'background');
            background.setScale(1.5); // Scale to fit 1200x1000 canvas (adjust as needed)
            background.setDepth(-3);

            // Create platform physics group (static - they don't move)
            platforms = this.physics.add.staticGroup();
            
            // Create all platforms from configuration using tileset tiles
            if (window.PlatformConfig) {
                const { PLATFORMS, PLATFORM_TYPES } = window.PlatformConfig;
                
                PLATFORMS.forEach(platformData => {
                    // Create platform container to hold sprites
                    const platformContainer = this.add.container(
                        platformData.x + 200, // Offset by 200px to center in 1200px canvas
                        platformData.y
                    );
                    
                    // Different rendering based on platform type
                    if (platformData.type === PLATFORM_TYPES.ONE_WAY) {
                        // Use Flag.png for one-way platforms - flag is now 60px wide
                        const flagsHorizontal = Math.ceil(platformData.width / 60); // 60px wide flags
                        for (let x = 0; x < flagsHorizontal; x++) {
                            const flag = this.add.image(
                                (x * 60) - (platformData.width / 2) + 30, // Center 60px flags
                                0, // Center vertically
                                'flag'
                            );
                            // No scaling needed - flag is already 60px wide
                            platformContainer.add(flag);
                        }
                    } else {
                        // For SOLID and SPAWN platforms, use appropriate tileset
                        switch (platformData.type) {
                            case PLATFORM_TYPES.SOLID:
                                // For solid platforms, prefer 96x96 tiles for larger platforms
                                if (platformData.width >= 96 && platformData.height >= 96) {
                                    // Use 96x96 tiles - skip initial 32px gap by using frame 1
                                    const tilesHorizontal = Math.ceil(platformData.width / 96);
                                    const tilesVertical = Math.ceil(platformData.height / 96);
                                    
                                    for (let x = 0; x < tilesHorizontal; x++) {
                                        for (let y = 0; y < tilesVertical; y++) {
                                            const tile = this.add.image(
                                                (x * 96) - (platformData.width / 2) + 48, // Center 96px tiles
                                                (y * 96) - (platformData.height / 2) + 48,
                                                'tileset-96',
                                                0 // Frame 1 to skip initial 32px gap manually
                                            );
                                            platformContainer.add(tile);
                                        }
                                    }
                                } else if (platformData.height >= 96 && platformData.width < 96) {
                                    // Use 32x96 vertical tiles for tall, narrow platforms
                                    const tilesHorizontal = Math.ceil(platformData.width / 32);
                                    const tilesVertical = Math.ceil(platformData.height / 96);
                                    
                                    for (let x = 0; x < tilesHorizontal; x++) {
                                        for (let y = 0; y < tilesVertical; y++) {
                                            const tile = this.add.image(
                                                (x * 32) - (platformData.width / 2) + 16, // Center 32px tiles
                                                (y * 96) - (platformData.height / 2) + 48, // Center 96px tiles
                                                'tileset-32x96',
                                                0 // Frame 0 = first 32x96 tile
                                            );
                                            platformContainer.add(tile);
                                        }
                                    }
                                } else {
                                    // Fall back to 32x32 tiles for smaller platforms
                                    const tilesHorizontal = Math.ceil(platformData.width / 32);
                                    const tilesVertical = Math.ceil(platformData.height / 32);
                                    
                                    for (let x = 0; x < tilesHorizontal; x++) {
                                        for (let y = 0; y < tilesVertical; y++) {
                                            const tile = this.add.image(
                                                (x * 32) - (platformData.width / 2) + 16, // Center tiles
                                                (y * 32) - (platformData.height / 2) + 16,
                                                'tileset-32',
                                                2 // Frame 2 = a suitable 32x32 solid tile
                                            );
                                            platformContainer.add(tile);
                                        }
                                    }
                                }
                                break;
                                
                            case PLATFORM_TYPES.SPAWN:
                                // SPAWN platforms are invisible but still functional for collision
                                // Create invisible tiles for spawn platforms
                                const spawnTilesHorizontal = Math.ceil(platformData.width / 32);
                                const spawnTilesVertical = Math.ceil(platformData.height / 32);
                                
                                for (let x = 0; x < spawnTilesHorizontal; x++) {
                                    for (let y = 0; y < spawnTilesVertical; y++) {
                                        const tile = this.add.image(
                                            (x * 32) - (platformData.width / 2) + 16, // Center tiles
                                            (y * 32) - (platformData.height / 2) + 16,
                                            'tileset-32',
                                            5 // Frame 5 = a special spawn platform tile (adjust as needed)
                                        );
                                        // Make spawn platforms invisible
                                        tile.setAlpha(0);
                                        platformContainer.add(tile);
                                    }
                                }
                                break;
                                
                            default:
                                // Default to 32x32 tiles
                                const defaultTilesH = Math.ceil(platformData.width / 32);
                                const defaultTilesV = Math.ceil(platformData.height / 32);
                                
                                for (let x = 0; x < defaultTilesH; x++) {
                                    for (let y = 0; y < defaultTilesV; y++) {
                                        const tile = this.add.image(
                                            (x * 32) - (platformData.width / 2) + 16,
                                            (y * 32) - (platformData.height / 2) + 16,
                                            'tileset-32',
                                            3
                                        );
                                        platformContainer.add(tile);
                                    }
                                }
                        }
                    }
                    
                    // Add to platforms group
                    platforms.add(platformContainer);
                    
                    // Store platform data for collision detection
                    platformContainer.platformData = platformData;
                });
                
                console.log(`Created ${PLATFORMS.length} platforms with tiled sprites`);
            } else {
                console.error('Platform configuration not loaded!');
            }

            // Create animations for all characters
            SAMURAI_CHARACTERS.forEach(character => {
                Object.keys(SPRITE_CONFIG).forEach(action => {
                    const config = SPRITE_CONFIG[action];
                    const animKey = `${character}-${action.toLowerCase().replace(' ', '-')}`;
                    
                    this.anims.create({
                        key: animKey,
                        frames: this.anims.generateFrameNumbers(`${character}-${action.toLowerCase().replace(' ', '-')}`, {
                            start: 0,
                            end: config.frames - 1
                        }),
                        frameRate: config.frameRate,
                        repeat: action === 'IDLE' || action === 'RUN' || action === 'BLOCK' ? -1 : 0
                    });
                });
            });

            console.log('[SPRITES] Created animations for', SAMURAI_CHARACTERS.length, 'characters');
            
            cursors = this.input.keyboard.createCursorKeys();
            spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            zKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
            
            // Dash input keys
            shiftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
            
            // Set camera bounds to show the full expanded area
            this.cameras.main.setBounds(0, 0, 1200, 1000);
            // Center camera on the main play area initially  
            this.cameras.main.setScroll(0, 0);
            
            // Store reference to scene for collision callbacks
            window.gameScene = this;
            
            // Initialize disconnection countdown interval tracker
            this.disconnectionCountdownInterval = null;

            // DOM-based disconnection countdown helpers
            this.showDisconnectionCountdown = (event) => {
                const toast      = document.getElementById('disconnect-countdown');
                const messageEl  = document.getElementById('disconnect-message');
                const timerEl    = document.getElementById('disconnect-timer');

                let timeLeft = event.gracePeriodSeconds || 10;

                messageEl.textContent = event.message || 'Waiting for reconnection...';
                timerEl.textContent   = timeLeft;
                toast.style.display   = 'block';

                // Clear any previous interval
                if (this.disconnectionCountdownInterval) {
                    clearInterval(this.disconnectionCountdownInterval);
                }

                // Start countdown
                this.disconnectionCountdownInterval = setInterval(() => {
                    timeLeft--;
                    timerEl.textContent = timeLeft;

                    // Simple pulse effect for urgency
                    if (timeLeft <= 5) {
                        toast.style.transform = 'translate(-50%, -50%) scale(1.05)';
                        setTimeout(() => {
                            toast.style.transform = 'translate(-50%, -50%) scale(1)';
                        }, 150);
                    }

                    // Auto-hide when finished
                    if (timeLeft <= 0) {
                        this.hideDisconnectionCountdown();
                    }
                }, 1000);
            };

            this.hideDisconnectionCountdown = () => {
                const toast = document.getElementById('disconnect-countdown');
                toast.style.display = 'none';

                if (this.disconnectionCountdownInterval) {
                    clearInterval(this.disconnectionCountdownInterval);
                    this.disconnectionCountdownInterval = null;
                }
            };
            
            // Prediction toggle key
            const pKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
            pKey.on('down', () => {
                predictionEnabled = !predictionEnabled;
                console.log(`Prediction toggled: ${predictionEnabled ? 'ON' : 'OFF'} (30fps sync'd with server)`);
                
                // Show/hide debug UI based on prediction state
                const debugPanel = document.getElementById('prediction-debug');
                if (debugPanel) {
                    debugPanel.style.display = predictionEnabled ? 'block' : 'none';
                }
                
                if (!predictionEnabled) {
                    clientPlayerState = null; // Reset client state
                    console.log('Client state reset - prediction disabled');
                    // Force sprite to server position
                    if (myPlayerId && playerSprites[myPlayerId] && gameState.players[myPlayerId]) {
                        const serverPlayer = gameState.players[myPlayerId];
                        const yOffset = playerSprites[myPlayerId].characterYOffset || 0;
                        playerSprites[myPlayerId].setPosition(serverPlayer.x + 200, serverPlayer.y + yOffset);
                    }
                } else {
                    console.log(`Prediction enabled - 30fps client physics (deltaTime: ${(1/PHYSICS_CONSTANTS.FRAME_RATE).toFixed(4)}s)`);
                }
                updateDebugPanel();
            });
            
            // Force resync key (R key)
            const rKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
            rKey.on('down', () => {
                if (predictionEnabled && myPlayerId && gameState.players[myPlayerId] && clientPlayerState) {
                    const serverPlayer = gameState.players[myPlayerId];
                    
                    console.log(`[FORCE RESYNC] Before - Client: (${clientPlayerState.x.toFixed(1)}, ${clientPlayerState.y.toFixed(1)}) | Server: (${serverPlayer.x.toFixed(1)}, ${serverPlayer.y.toFixed(1)})`);
                    
                    // Force client state to exactly match server
                    clientPlayerState.x = serverPlayer.x;
                    clientPlayerState.y = serverPlayer.y;
                    clientPlayerState.velocityX = serverPlayer.velocityX || 0;
                    clientPlayerState.velocityY = serverPlayer.velocityY || 0;
                    clientPlayerState.isGrounded = serverPlayer.isGrounded;
                    clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
                    
                    // Update sprite position
                    if (playerSprites[myPlayerId]) {
                        const yOffset = playerSprites[myPlayerId].characterYOffset || 0;
                        playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y + yOffset);
                        updateLocalPlayerHealthBar();
                    }
                    
                    console.log(`[FORCE RESYNC] After - Client: (${clientPlayerState.x.toFixed(1)}, ${clientPlayerState.y.toFixed(1)}) | Sprite: (${playerSprites[myPlayerId].x - 200}, ${playerSprites[myPlayerId].y})`);
                    console.log('[FORCE RESYNC] Client state forcibly synchronized with server');
                }
            });
            
            // Initialize socket connection with auth token
            socket = io({
                auth: {
                    token: authToken
                }
            });
            myPlayerId = socket.id;
            
            socket.on('gameState', (newGameState) => {
                gameState = newGameState;
                
                // Client-side prediction reconciliation
                if (predictionEnabled && myPlayerId) {
                    reconcileWithServer(newGameState);
                }
                
                updatePlayerCount();
                updatePlayerSprites.call(this);
                updateUI();
            });
            
            // Handle optimized platform data (sent separately)
            socket.on('platformData', (platformData) => {
                console.log(`[OPTIMIZATION] Received platform data for room ${platformData.roomCode}`);
                gameState.platforms = platformData.platforms;
                // Platforms are static and already rendered in create() - no need to re-render
            });
            
            socket.on('connect', () => {
                myPlayerId = socket.id;
                console.log(`[CONNECTION] Connected with socket ID: ${socket.id}`);
                
                // Measure initial connection latency
                const connectionStart = Date.now();
                socket.emit('ping', connectionStart);
            });
            
            // Latency measurement for debugging
            socket.on('pong', (timestamp) => {
                const latency = Date.now() - timestamp;
                console.log(`[LATENCY] Round-trip time: ${latency}ms`);
                
                // Update debug panel with latency info
                const latencyElement = document.getElementById('latency');
                if (latencyElement) {
                    latencyElement.textContent = `${latency}ms`;
                    
                    // Color-code latency for visual feedback
                    if (latency < 50) {
                        latencyElement.style.color = '#FF8C42'; // Orange - excellent
                    } else if (latency < 100) {
                        latencyElement.style.color = '#ffff66'; // Yellow - good
                    } else if (latency < 200) {
                        latencyElement.style.color = '#ff9966'; // Orange - fair
                    } else {
                        latencyElement.style.color = '#ff6666'; // Red - poor
                    }
                }
            });
            
            // Listen for jump events for visual effects
            socket.on('playerJump', (jumpEvent) => {
                handleJumpEvent.call(this, jumpEvent);
            });
            
            // Listen for dash events for visual effects
            socket.on('playerDash', (dashEvent) => {
                handleDashEvent.call(this, dashEvent);
            });
            
            // Listen for death events
            socket.on('playerDeath', (deathEvent) => {
                handlePlayerDeath.call(this, deathEvent);
            });
            
            // Listen for respawn events
            socket.on('playerRespawn', (respawnEvent) => {
                handlePlayerRespawn.call(this, respawnEvent);
            });
            
            // Listen for elimination events
            socket.on('playerEliminated', (eliminationEvent) => {
                handlePlayerElimination.call(this, eliminationEvent);
            });
            
            // Listen for match end events
            socket.on('matchEnd', (matchEndEvent) => {
                handleMatchEnd.call(this, matchEndEvent);
            });
            
            // Listen for match reset events
            socket.on('matchReset', (resetEvent) => {
                handleMatchReset.call(this, resetEvent);
            });
            
            // Listen for invincibility end events
            socket.on('playerInvincibilityEnd', (invincibilityEvent) => {
                handleInvincibilityEnd.call(this, invincibilityEvent);
            });
            
            // ==================== ROOM EVENT HANDLERS ====================
            
            // Listen for new players joining the room
            socket.on('playerJoinedRoom', (event) => {
                if (currentRoom) {
                    const playerName = event.playerName || `Player ${event.socketId.substring(0, 8)}...`;
                    showMessage(`${playerName} joined the room (${event.playerCount}/8)`, 'success');
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                }
            });
            
            // Listen for players leaving the room
            socket.on('playerLeftRoom', (event) => {
                if (currentRoom) {
                    let message = `Player left the room (${event.playerCount}/8)`;
                    
                    if (event.reason === 'disconnect') {
                        message = `Player disconnected (${event.playerCount}/8)`;
                    }
                    
                    showMessage(message, 'info');
                    
                    // Update host status if needed
                    if (event.newHostId === socket.id) {
                        isHost = true;
                        startGameBtn.style.display = 'block';
                        showMessage('You are now the host!', 'success');
                    }
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                }
            });
            
            // Listen for room closure
            socket.on('roomClosed', (event) => {
                currentRoom = null;
                isHost = false;
                gameStarted = false;
                
                // Hide game over screen if visible
                hideGameOverScreen();
                
                // Hide disconnection countdown if visible
                if (window.gameScene) {
                    window.gameScene.hideDisconnectionCountdown();
                }
                
                // Show main menu
                roomUI.style.display = 'block';
                showMainMenu();
                
                // Show appropriate message
                const message = event.message || `Room closed: ${event.reason || 'Unknown reason'}`;
                showMessage(message, 'error');
            });
            
            // Listen for room errors
            socket.on('roomError', (error) => {
                showMessage(error.message, 'error');
            });
            
            // ==================== GAME START EVENT HANDLERS ====================
            
            // Listen for game start countdown
            socket.on('gameStartCountdown', (event) => {
                console.log('Game start countdown:', event.countdown);
                
                const countdownEl = document.getElementById('game-start-countdown');
                const countdownNumberEl = countdownEl.querySelector('.countdown-number');
                
                // Hide room UI during countdown
                roomUI.style.display = 'none';
                
                // Show countdown with current number
                countdownNumberEl.textContent = event.countdown;
                countdownEl.style.display = 'block';
                
                // Play countdown sound effect (if available)
                // You could add audio here: new Audio('countdown.mp3').play();
            });
            
            // Listen for game started
            socket.on('gameStarted', (event) => {
                console.log('Game started!', event);
                
                const countdownEl = document.getElementById('game-start-countdown');
                const countdownNumberEl = countdownEl.querySelector('.countdown-number');
                const countdownTextEl = countdownEl.querySelector('.countdown-text');
                
                // Show "FIGHT!" message
                countdownTextEl.textContent = 'FIGHT!';
                countdownNumberEl.textContent = '';
                countdownEl.style.color = '#FF6B35'; // Orange color for "FIGHT!"
                
                // Hide countdown after 1 second and start game
                setTimeout(() => {
                    countdownEl.style.display = 'none';
                    
                    // Reset countdown display for next time
                    countdownTextEl.textContent = 'Game Starting...';
                    countdownEl.style.color = '#F36D32';
                    
                    // Hide room UI and start the game
                    hideRoomUI();
                    gameStarted = true;
                    
                    // Reset the start button for next game
                    startGameBtn.disabled = false;
                    startGameBtn.textContent = 'Start Game';
                    
                    showMessage('Game started! Fight!', 'success');
                }, 1000);
                
                // Play game start sound effect (if available)
                // You could add audio here: new Audio('fight.mp3').play();
            });
            
            // ==================== END GAME START EVENT HANDLERS ====================
            
            // ==================== GAME OVER EVENT HANDLERS ====================
            
            // Listen for game over event
            socket.on('gameOver', (gameOverData) => {
                console.log('Game Over received:', gameOverData);
                if (window.gameScene) {
                    window.gameScene.hideDisconnectionCountdown();
                }
                showGameOverScreen(gameOverData);
            });
            
            // Listen for rematch starting
            socket.on('rematchStarting', (event) => {
                console.log('Rematch starting:', event);
                hideGameOverScreen();
                
                // Reset the rematch button
                rematchBtn.disabled = false;
                rematchBtn.textContent = 'Rematch';
                
                showMessage('Rematch starting!', 'success');
            });
            
            // Listen for return to lobby response
            socket.on('returnedToLobby', (event) => {
                console.log('Returned to lobby:', event);
                hideGameOverScreen();
                // Show room UI again
                roomUI.style.display = 'block';
                showRoomLobby(event.roomCode, event.isHost);
                currentRoom = { code: event.roomCode };
                isHost = event.isHost;
                
                console.log(`Returned to lobby - isHost: ${isHost}, startGameBtn display: ${startGameBtn.style.display}`);
                
                // Request updated room info to refresh player list
                socket.emit('getRoomInfo', (roomInfo) => {
                    if (roomInfo.success) {
                        updatePlayerList(roomInfo.players);
                    }
                });
            });
            
            // Listen for room joined event (also triggered on return to lobby)
            socket.on('roomJoined', (event) => {
                console.log('Room joined/rejoined:', event);
                
                if (event.rejoined && event.gameInProgress) {
                    // Player rejoined an active game - don't show room UI, just continue playing
                    console.log('Rejoined active game - continuing where left off');
                    currentRoom = { code: event.roomCode };
                    isHost = event.isHost;
                    gameStarted = true;
                    
                    // Hide any UI that might be visible
                    hideMainMenu();
                    hideGameOverScreen();
                    roomUI.style.display = 'none';
                    
                    showMessage('Welcome back! You have rejoined the game.', 'success', 3000);
                } else {
                    // Normal room join or return to lobby
                    roomUI.style.display = 'block';
                    showRoomLobby(event.roomCode, event.isHost);
                    currentRoom = { code: event.roomCode };
                    isHost = event.isHost;
                    
                    console.log(`Room joined/returned to lobby - isHost: ${isHost}, showing start button: ${isHost ? 'yes' : 'no'}`);
                    
                    // Update player list if provided
                    if (event.players) {
                        updatePlayerList(event.players);
                    }
                }
            });
            
            // Listen for other players returning to lobby
            socket.on('playerReturnedToLobby', (event) => {
                console.log('Player returned to lobby:', event);
                
                // Update player list if we're in the same room and showing lobby
                if (currentRoom && currentRoom.code === event.roomCode && roomLobby.style.display !== 'none') {
                    updatePlayerList(event.players);
                    playerCount.textContent = event.playerCount;
                }
            });
            
            // Listen for player disconnection grace period
            socket.on('playerDisconnectedGracePeriod', (event) => {
                console.log('Player disconnected - grace period started:', event);
                if (window.gameScene) {
                    window.gameScene.showDisconnectionCountdown(event);
                }
            });
            
            // Listen for player rejoining during grace period
            socket.on('playerRejoinedGame', (event) => {
                console.log('Player rejoined game:', event);
                if (window.gameScene) {
                    window.gameScene.hideDisconnectionCountdown();
                }
                showMessage(event.message, 'success', 3000);
            });
            
            // Listen for host transfer events
            socket.on('hostTransferred', (event) => {
                console.log('Host transferred:', event);
                if (event.newHostId === socket.id) {
                    isHost = true;
                    startGameBtn.style.display = 'block';
                    showMessage(event.message, 'success', 5000);
                }
            });
            
            // ==================== END GAME OVER EVENT HANDLERS ====================
            
            // ==================== END ROOM EVENT HANDLERS ====================
        }

        function updatePlayerSprites() {
            // Remove sprites for disconnected players
            for (const id in playerSprites) {
                if (!gameState.players[id]) {
                    playerSprites[id].destroy();
                    if (playerHealthBars[id]) {
                        playerHealthBars[id].background.destroy();
                        playerHealthBars[id].fill.destroy();
                    }
                    if (playerAttackEffects[id]) {
                        playerAttackEffects[id].destroy();
                    }
                    delete playerSprites[id];
                    delete playerHealthBars[id];
                    delete playerAttackEffects[id];
                    
                    // Clean up character assignments
                    delete playerCharacters[id];
                }
            }
            
            // Update or create sprites for connected players
            for (const id in gameState.players) {
                const player = gameState.players[id];
                
                if (!playerSprites[id]) {
                    // Use character assignment from server (player.character)
                    const assignedCharacter = player.character || 'samurai-1'; // Default fallback
                    playerCharacters[id] = assignedCharacter;
                    
                    console.log(`[SPRITES] Using server-assigned character ${assignedCharacter} for player ${id} with tint: 0x${(player.characterTint || 0xffffff).toString(16)}`);
                    
                    // Create new player sprite using character base texture (first frame)
                    const baseCharacterKey = `${playerCharacters[id]}-idle`;
                    const characterYOffset = CHARACTER_Y_OFFSETS[playerCharacters[id]] || 0;
                    playerSprites[id] = this.add.sprite(player.x + 200, player.y + characterYOffset, baseCharacterKey, 0); // Use frame 0
                    playerSprites[id].setScale(1.2); // Doubled from 0.6 to 1.2 for larger characters
                    
                    // Store player ID and character on sprite for reference
                    playerSprites[id].playerId = id;
                    playerSprites[id].character = playerCharacters[id];
                    playerSprites[id].characterYOffset = characterYOffset; // Store offset for position updates
                    
                    // Start with idle animation - check if animation exists first
                    const idleAnimKey = `${playerCharacters[id]}-idle`;
                    if (this.anims.exists(idleAnimKey)) {
                        playerSprites[id].play(idleAnimKey);
                    } else {
                        console.warn(`[SPRITES] Animation ${idleAnimKey} not found for player ${id}`);
                    }
                    
                    // Create health bar background
                    const healthBarBg = this.add.rectangle(player.x + 200, player.y - 40, 50, 8, 0x333333);
                    const healthBarFill = this.add.rectangle(player.x + 200, player.y - 40, 48, 6, 0xF36D32);
                    
                    playerHealthBars[id] = {
                        background: healthBarBg,
                        fill: healthBarFill
                    };
                    
                    // Create attack effect (initially invisible)
                    playerAttackEffects[id] = this.add.circle(player.x + 200, player.y, 35, 0xffff00, 0.6);
                    playerAttackEffects[id].setVisible(false);
                } else {
                    // Update existing sprite position
                    // For local player: only use server position if prediction is disabled
                    if (id === myPlayerId && predictionEnabled && clientPlayerState) {
                        // Use predicted position for local player
                        const yOffset = playerSprites[id].characterYOffset || 0;
                        playerSprites[id].setPosition(clientPlayerState.x + 200, clientPlayerState.y + yOffset);
                    } else {
                        // Use server position for other players or when prediction is off
                        const yOffset = playerSprites[id].characterYOffset || 0;
                        playerSprites[id].setPosition(player.x + 200, player.y + yOffset);
                    }
                    
                    // Update sprite animation and effects based on player state
                    const character = playerCharacters[id] || player.character || 'samurai-1';
                    let targetAnim = `${character}-idle`;
                    let playerAlpha = 1.0;
                    let stateTint = null; // State-based tint (overrides character tint)
                    
                    // Get the base character tint from server (for duplicate characters)
                    let baseTint = player.characterTint || 0xffffff;
                    
                    // Determine animation based on player state (priority order)
                    if (player.eliminated || player.health <= 0) {
                        targetAnim = `${character}-death`;
                        playerAlpha = 0.5;
                        stateTint = 0x666666; // Gray tint when dead
                    } else if (player.isDead) {
                        targetAnim = `${character}-hurt`;
                        playerAlpha = 0.6;
                        stateTint = 0xff6666; // Red tint when hurt
                    } else if (player.attacking) {
                        // Use attack-2 for samurai-1, attack-1 for all other characters
                        const attackType = character === 'samurai-1' ? 'attack-2' : 'attack-1';
                        targetAnim = `${character}-${attackType}`;
                    } else if (player.blocking) {
                        targetAnim = `${character}-block`;
                        stateTint = 0xffff66; // Yellow tint when blocking
                    } else if (player.velocityY < -50) {
                        targetAnim = `${character}-jump`;
                    } else if (Math.abs(player.velocityX) > 1) {
                        targetAnim = `${character}-run`;
                        // Flip sprite based on movement direction
                        playerSprites[id].setFlipX(player.velocityX < 0);
                    } else {
                        targetAnim = `${character}-idle`;
                    }
                    
                    // Apply invincibility blinking effect
                    if (player.isInvincible) {
                        playerAlpha = 0.7 + Math.sin(Date.now() * 0.01) * 0.3; // Blinking effect
                        stateTint = 0x66ffff; // Cyan tint when invincible
                    }
                    
                    // Determine final tint: state tints override character tints
                    const finalTint = stateTint || baseTint;
                    
                    // Apply visual effects
                    playerSprites[id].setAlpha(playerAlpha);
                    playerSprites[id].setTint(finalTint);
                    
                    // Update animation if it changed - check if animation exists first
                    if (playerSprites[id].anims.currentAnim?.key !== targetAnim) {
                        if (this.anims.exists(targetAnim)) {
                            playerSprites[id].play(targetAnim);
                        } else {
                            console.warn(`[SPRITES] Animation ${targetAnim} not found for player ${id}`);
                        }
                    }
                    
                    // Update health bar position and fill
                    // Keep health bar position consistent with sprite position
                    if (playerHealthBars[id]) {
                        const healthBarX = (id === myPlayerId && predictionEnabled && clientPlayerState) ? 
                            clientPlayerState.x + 200 : player.x + 200;
                        const healthBarY = (id === myPlayerId && predictionEnabled && clientPlayerState) ? 
                            clientPlayerState.y - 40 : player.y - 40;
                        
                        playerHealthBars[id].background.x = healthBarX;
                        playerHealthBars[id].background.y = healthBarY;
                        playerHealthBars[id].fill.x = healthBarX;
                        playerHealthBars[id].fill.y = healthBarY;
                    
                        // Update health bar width based on health
                        const healthPercent = player.health / 100;
                        playerHealthBars[id].fill.scaleX = healthPercent;
                        
                        // Update health bar color based on health
                        if (healthPercent > 0.6) {
                            playerHealthBars[id].fill.setFillStyle(0xF36D32);
                        } else if (healthPercent > 0.3) {
                            playerHealthBars[id].fill.setFillStyle(0xffff00);
                        } else {
                            playerHealthBars[id].fill.setFillStyle(0xff0000);
                        }
                    }
                    
                    // Update attack effect
                    if (player.attacking && playerAttackEffects[id]) {
                        playerAttackEffects[id].x = player.x + 200; // Add 200px offset
                        playerAttackEffects[id].y = player.y;
                        playerAttackEffects[id].setVisible(true);
                    } else if (playerAttackEffects[id]) {
                        playerAttackEffects[id].setVisible(false);
                    }
                }
            }
        }

        function updatePlayerCount() {
            const count = Object.keys(gameState.players).length;
            document.getElementById('player-count').textContent = `Players: ${count}`;
        }

        let lastUIUpdate = 0;
        let lastPlayerState = {};
        const UI_UPDATE_INTERVAL = 50; // Update UI only every 50ms
        
        function updateUI() {
            const now = Date.now();
            const myPlayer = gameState.players[myPlayerId];
            
            if (!myPlayer) return;
            
            // Check if any player state has changed
            const allPlayersState = Object.keys(gameState.players).map(id => {
                const player = gameState.players[id];
                return {
                    id: id,
                    lives: player.lives,
                    eliminated: player.eliminated,
                    isDead: player.isDead,
                    isInvincible: player.isInvincible
                };
            });
            
            const allPlayersStateStr = JSON.stringify(allPlayersState);
            const stateChanged = allPlayersStateStr !== JSON.stringify(lastPlayerState);
            
            // Throttle UI updates unless state changed
            if (!stateChanged && now - lastUIUpdate < UI_UPDATE_INTERVAL) {
                return;
            }
            
            lastUIUpdate = now;
            lastPlayerState = allPlayersState;
            
            // Update players panel
            updatePlayersPanel();
            
            // Update match status for current player
            const statusElement = document.getElementById('match-status');
            if (myPlayer.eliminated) {
                statusElement.textContent = 'ELIMINATED - Spectating';
                statusElement.style.color = '#ff6666';
            } else if (myPlayer.isDead) {
                statusElement.textContent = 'RESPAWNING...';
                statusElement.style.color = '#ffff66';
            } else if (myPlayer.isInvincible) {
                statusElement.textContent = 'INVINCIBLE';
                statusElement.style.color = '#66ffff';
            } else {
                statusElement.textContent = '';
            }
        }

        function updatePlayersPanel() {
            const playersPanel = document.getElementById('players-panel');
            if (!playersPanel) return;
            
            // Clear existing content
            playersPanel.innerHTML = '';
            
            // Get all players sorted by ID for consistent ordering
            const playerIds = Object.keys(gameState.players).sort();
            
            playerIds.forEach(playerId => {
                const player = gameState.players[playerId];
                if (!player) return;
                
                // Create player info container
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                
                // Create player name
                const playerName = document.createElement('div');
                playerName.className = 'player-name';
                
                // Get player display name from server (with fallback)
                let displayName = player.displayName || `Player ${playerId.substring(0, 6)}`;
                
                // Highlight current player
                if (playerId === myPlayerId) {
                    playerName.classList.add('current-player');
                    displayName += ' (You)';
                }
                
                // Mark eliminated players
                if (player.eliminated) {
                    playerName.classList.add('eliminated');
                }
                
                // Create inner text element for marquee
                const playerNameText = document.createElement('span');
                playerNameText.className = 'player-name-text';
                playerNameText.textContent = displayName;
                
                // Check if text is too long and needs marquee
                playerName.appendChild(playerNameText);
                
                // Measure text width to determine if marquee is needed
                setTimeout(() => {
                    const textWidth = playerNameText.offsetWidth;
                    const containerWidth = playerName.offsetWidth;
                    
                    if (textWidth > containerWidth) {
                        playerNameText.classList.add('marquee');
                    }
                }, 10);
                
                playerInfo.appendChild(playerName);
                
                // Create lives display with hearts
                const playerLives = document.createElement('div');
                playerLives.className = 'player-lives';
                
                // Add hearts for each life (max 3)
                for (let i = 0; i < 3; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'heart-icon';
                    
                    // Make hearts look "lost" if player doesn't have this life
                    if (i >= player.lives) {
                        heart.classList.add('lost');
                    }
                    
                    playerLives.appendChild(heart);
                }
                
                playerInfo.appendChild(playerLives);
                playersPanel.appendChild(playerInfo);
            });
        }



        function update(time, delta) {
            const deltaTime = delta / 1000; // 0.0333 seconds every tick when fps.target is 30
            const currentTime = Date.now();
            
            // Dash input detection system
            let dashDirection = null; // null, 'left', or 'right'
            
            // Update dash input cooldown
            if (dashInputCooldown > 0) {
                dashInputCooldown -= delta; // Use the real frame time
            }
            
            // Check for dedicated dash key (Shift) + direction
            if (Phaser.Input.Keyboard.JustDown(shiftKey) && dashInputCooldown <= 0) {
                if (cursors.left.isDown) {
                    dashDirection = 'left';
                    dashInputCooldown = DASH_INPUT_COOLDOWN;
                } else if (cursors.right.isDown) {
                    dashDirection = 'right';
                    dashInputCooldown = DASH_INPUT_COOLDOWN;
                }
            }
            
            // Check for double-tap dash (left/right keys)
            if (dashInputCooldown <= 0) {
                // Left key double-tap detection
                if (Phaser.Input.Keyboard.JustDown(cursors.left)) {
                    if (currentTime - lastLeftKeyTime <= DASH_DOUBLE_TAP_WINDOW) {
                        dashDirection = 'left';
                        dashInputCooldown = DASH_INPUT_COOLDOWN;
                    }
                    lastLeftKeyTime = currentTime;
                }
                
                // Right key double-tap detection  
                if (Phaser.Input.Keyboard.JustDown(cursors.right)) {
                    if (currentTime - lastRightKeyTime <= DASH_DOUBLE_TAP_WINDOW) {
                        dashDirection = 'right';
                        dashInputCooldown = DASH_INPUT_COOLDOWN;
                    }
                    lastRightKeyTime = currentTime;
                }
            }
            
            const inputs = {
                left: cursors.left.isDown,
                right: cursors.right.isDown,
                jump: Phaser.Input.Keyboard.JustDown(cursors.up),
                attack: Phaser.Input.Keyboard.JustDown(spaceKey),
                block: zKey.isDown,
                down: cursors.down.isDown,
                dash: dashDirection // Add dash direction to inputs
            };
            
            // Client-side prediction for smooth gameplay
            if (predictionEnabled && myPlayerId && gameState.players[myPlayerId]) {
                // Initialize client state if needed
                if (!clientPlayerState) {
                    initializeClientPlayerState();
                }
                
                // Apply inputs immediately on client for responsiveness
                applyClientSidePrediction(inputs, deltaTime);
                
                // Buffer input for server reconciliation
                bufferInput(inputs);
            }
            
            socket.emit('input', inputs);
        }
        
        // Client-side prediction functions
        function initializeClientPlayerState() {
            const serverPlayer = gameState.players[myPlayerId];
            if (!serverPlayer) return;
            
            console.log(`[CLIENT INIT] Initializing client state from server position: (${serverPlayer.x}, ${serverPlayer.y})`);
            
            // Perfect sync with server state
            clientPlayerState = {
                x: serverPlayer.x,
                y: serverPlayer.y,
                velocityX: serverPlayer.velocityX || 0,
                velocityY: serverPlayer.velocityY || 0,
                isGrounded: serverPlayer.isGrounded !== undefined ? serverPlayer.isGrounded : true,
                jumpsRemaining: serverPlayer.jumpsRemaining || 2,
                lastJumpTime: serverPlayer.lastJumpTime || 0,
                blocking: serverPlayer.blocking || false,
                health: serverPlayer.health,
                droppingTimer: 0, // frames left to ignore one-way collisions
                isDashing: false, // New for dash state
                dashDirection: 0, // New for dash direction
                dashStartTime: 0, // New for dash start time
                lastDashTime: 0, // New for last dash time
                dashVelocity: 0 // New for dash velocity
            };
            
            console.log(`[CLIENT INIT] Client state initialized:`, clientPlayerState);
            
            // Force immediate position sync to eliminate initial error
            if (playerSprites[myPlayerId]) {
                const yOffset = playerSprites[myPlayerId].characterYOffset || 0;
                console.log(`[CLIENT INIT] Setting sprite position to (${clientPlayerState.x + 200}, ${clientPlayerState.y + yOffset})`);
                playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y + yOffset);
                updateLocalPlayerHealthBar();
            }
            
            // Verify initial synchronization
            const initialError = Math.sqrt(
                Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                Math.pow(clientPlayerState.y - serverPlayer.y, 2)
            );
            console.log(`[CLIENT INIT] Initial synchronization error: ${initialError.toFixed(3)}px (should be 0.000)`);
        }
        
        function updateLocalPlayerHealthBar() {
            if (predictionEnabled && myPlayerId && clientPlayerState && playerHealthBars[myPlayerId]) {
                const healthBarX = clientPlayerState.x + 200; // Add 200px offset
                const healthBarY = clientPlayerState.y - 40;
                
                playerHealthBars[myPlayerId].background.x = healthBarX;
                playerHealthBars[myPlayerId].background.y = healthBarY;
                playerHealthBars[myPlayerId].fill.x = healthBarX;
                playerHealthBars[myPlayerId].fill.y = healthBarY;
            }
        }

        // Utility: returns true if we should ignore one-way platforms this frame
        function isDroppingThrough() {
            return clientPlayerState && clientPlayerState.droppingTimer && clientPlayerState.droppingTimer > 0;
        }

        function getClientGroundState(player, ignoreOneWay) {
            const { PLATFORMS, PLATFORM_TYPES, PlatformUtils } = window.PlatformConfig;

            let isGrounded = false;
            let groundY = PHYSICS_CONSTANTS.GROUND_Y;
            let landedPlatform = null;

            // EXACT SERVER MATCH: Use the same collision logic as server
            for (const platform of PLATFORMS) {
                const playerBounds = PlatformUtils.getPlayerBounds(player);
                const platformBounds = PlatformUtils.getPlatformBounds(platform);
                
                // Check if player is horizontally aligned with platform (exact server logic)
                const isHorizontallyOverlapping = playerBounds.left < platformBounds.right && 
                                                 playerBounds.right > platformBounds.left;
                
                if (isHorizontallyOverlapping) {
                    const platformTop = platform.y - platform.height / 2;
                    const playerBottom = player.y + 40; // Player height/2 = 40px (exact server match)
                    
                    // MORE GENEROUS LANDING DETECTION: Increased tolerance and added velocity check
                    const distanceToTop = playerBottom - platformTop;
                    const isNearPlatform = distanceToTop >= -25 && distanceToTop <= 25; // INCREASED from 20 to 25px tolerance
                    
                    // IMPROVED: Also check if player is moving downward or stationary for landing
                    const isLandingCondition = player.velocityY >= -50; // Allow slight upward velocity for landing
                    
                    if (isNearPlatform && isLandingCondition) {
                        // For one-way platforms, handle dropping logic
                        if (platform.type === PLATFORM_TYPES.ONE_WAY) {
                            // Skip collision if ignoring one-way or actively dropping
                            if (ignoreOneWay || isDroppingThrough()) {
                                continue;
                            }
                            
                            // MORE GENEROUS: Allow landing even if player center is slightly below platform
                            if (player.y <= platformTop + 15) { // INCREASED from just "< platformTop" to allow 15px below
                                isGrounded = true;
                                groundY = PlatformUtils.getPlayerStandingY(platform);
                                landedPlatform = platform;
                                break;
                            }
                        } else {
                            // Solid platforms - can land from any direction (exact server logic)
                            isGrounded = true;
                            groundY = PlatformUtils.getPlayerStandingY(platform);
                            landedPlatform = platform;
                            break;
                        }
                    }
                }
            }

            return { isGrounded, groundY, platform: landedPlatform };
        }
 
        function applyClientSidePrediction(inputs, deltaTime) {
            // Use FIXED timestep to match server exactly (crucial for multiplayer sync)
            const now = Date.now();
            
            // Log initial state for debugging
            const preX = clientPlayerState.x;
            const preY = clientPlayerState.y;
            const preVelY = clientPlayerState.velocityY;
            
            // Apply same anti-cheat logic as server: prevent conflicting inputs
            let inputsCancelled = false;
            if (inputs.left && inputs.right) {
                inputs.left = false;
                inputs.right = false;
                inputsCancelled = true;
            }
            
            // Update debug panel input status
            const inputStatusElement = document.getElementById('input-status');
            if (inputStatusElement) {
                if (inputsCancelled) {
                    inputStatusElement.textContent = 'CANCELLED (L+R)';
                    inputStatusElement.style.color = '#ff6666';
                } else {
                    inputStatusElement.textContent = 'Normal';
                    inputStatusElement.style.color = '#FF8C42';
                }
            }
            
            const MOVE_SPEED_PER_TICK = 4;
            // SIMPLIFIED: More conservative movement prediction
            const moveSpeed = clientPlayerState.blocking 
                ? MOVE_SPEED_PER_TICK * 0.5
                : MOVE_SPEED_PER_TICK; // Match server MOVEMENT_SPEED
            // constants – put these near the other physics constants
            const DASH_VELOCITY = 900; // Match server DASH_VELOCITY (increased from 300)
            const DASH_DECAY_RATE = 0.85;
            const DASH_DURATION = 150;     // ms



            // Conservative movement handling to reduce divergence
            if (inputs.left) {
                clientPlayerState.x -= moveSpeed;
                clientPlayerState.velocityX = -moveSpeed;
            } else if (inputs.right) {
                clientPlayerState.x += moveSpeed;
                clientPlayerState.velocityX = moveSpeed;
            } else {
                clientPlayerState.velocityX = 0;
            }
            
            // Jump prediction with exact server matching
            if (inputs.jump && validateClientJump(now)) {
                performClientJump(now);
                console.log(`[CLIENT PHYSICS] Jump performed - velocity set to ${clientPlayerState.velocityY}`);
            }
            
            // Dash prediction with client-side validation
            if (inputs.dash && validateClientDash(now)) {
                performClientDash(inputs.dash, now);
            }

            if (clientPlayerState.isDashing) {
                const dashElapsed = now - clientPlayerState.dashStartTime;

                if (dashElapsed >= DASH_DURATION) {
                    clientPlayerState.isDashing = false;
                    clientPlayerState.dashVelocity = 0;
                    clientPlayerState.dashDirection = 0;
                } else {
                    clientPlayerState.dashVelocity *= DASH_DECAY_RATE;
                    clientPlayerState.x += clientPlayerState.dashVelocity * deltaTime;
                }
            }
            
            // IMPROVED VERTICAL PHYSICS: Better jump handling
            const serverPlayer = gameState.players[myPlayerId];
            
            // Safety check - if no server data, skip prediction this frame
            if (!serverPlayer) {
                return;
            }
            
            // Only override client physics for major disagreements
            const yDifference = Math.abs(clientPlayerState.y - serverPlayer.y);
            const shouldTrustServer = yDifference > 80 || // Extreme disagreement  
                                     (serverPlayer.isGrounded && !clientPlayerState.isGrounded && yDifference > 40); // Server says grounded, client doesn't
            
            if (shouldTrustServer) {
                // Major disagreement - gradually sync to server
                const yDiff = serverPlayer.y - clientPlayerState.y;
                console.log(`[CLIENT PHYSICS] Major disagreement detected! Y diff: ${yDiff.toFixed(1)}px, trusting server`);
                clientPlayerState.y += yDiff * 0.25; // Gentle correction
                clientPlayerState.velocityY = serverPlayer.velocityY || 0;
                clientPlayerState.isGrounded = serverPlayer.isGrounded;
                clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
            } else {
                // Normal prediction for small differences
                const ignoreOneWayNow = inputs.down || isDroppingThrough();
                let groundState = getClientGroundState(clientPlayerState, ignoreOneWayNow);

                // Handle drop-through for one-way platforms
                const wantsToDrop = inputs.down && groundState.isGrounded &&
                                    groundState.platform && groundState.platform.type === window.PlatformConfig.PLATFORM_TYPES.ONE_WAY;

                if (wantsToDrop) {
                    clientPlayerState.velocityY = Math.max(clientPlayerState.velocityY, 200);
                    clientPlayerState.droppingTimer = 12;
                    clientPlayerState.isGrounded = false;
                    console.log(`[CLIENT PHYSICS] Dropping through platform - velocityY set to ${clientPlayerState.velocityY}`);
                } else {
                    // Decrement dropping timer
                    if (clientPlayerState.droppingTimer && clientPlayerState.droppingTimer > 0) {
                        clientPlayerState.droppingTimer--;
                    }

                    // Apply gravity and vertical movement
                    if (!groundState.isGrounded) {
                        // Apply gravity consistently for airborne movement
                        const preGravityVelY = clientPlayerState.velocityY;
                        clientPlayerState.velocityY += PHYSICS_CONSTANTS.GRAVITY * deltaTime;
                        
                        // Cap maximum fall speed for more predictable physics
                        const maxFallSpeed = 800;
                        if (clientPlayerState.velocityY > maxFallSpeed) {
                            clientPlayerState.velocityY = maxFallSpeed;
                        }
                        
                        const preMovementY = clientPlayerState.y;
                        clientPlayerState.y += clientPlayerState.velocityY * deltaTime;
                        clientPlayerState.isGrounded = false;
                        
                        // Detailed gravity logging
                        if (Math.abs(preGravityVelY - clientPlayerState.velocityY) > 5) {
                            console.log(`[CLIENT PHYSICS] Gravity applied - velY: ${preGravityVelY.toFixed(1)} -> ${clientPlayerState.velocityY.toFixed(1)}, Y: ${preMovementY.toFixed(1)} -> ${clientPlayerState.y.toFixed(1)}`);
                        }
                    } else {
                        // Grounded - stop vertical movement and position exactly
                        if (!clientPlayerState.isGrounded) {
                            console.log(`[CLIENT PHYSICS] Landing detected - Y: ${clientPlayerState.y.toFixed(1)} -> ${groundState.groundY.toFixed(1)}, platform: ${groundState.platform?.id || 'ground'}`);
                        }
                        clientPlayerState.y = groundState.groundY;
                        clientPlayerState.velocityY = 0;
                        clientPlayerState.isGrounded = true;
                        clientPlayerState.jumpsRemaining = 2;
                    }
                }
            }
            
            // Update blocking state
            clientPlayerState.blocking = inputs.block;
            
            // Allow free movement beyond boundaries for fall-off deaths
            // No horizontal clamping - players can now fall off the sides
            
            // Log significant movement changes
            const totalMovement = Math.sqrt(
                Math.pow(clientPlayerState.x - preX, 2) + 
                Math.pow(clientPlayerState.y - preY, 2)
            );
            if (totalMovement > 5) {
                console.log(`[CLIENT MOVEMENT] Total: ${totalMovement.toFixed(1)}px | Pos: (${preX.toFixed(1)}, ${preY.toFixed(1)}) -> (${clientPlayerState.x.toFixed(1)}, ${clientPlayerState.y.toFixed(1)}) | VelY: ${preVelY.toFixed(1)} -> ${clientPlayerState.velocityY.toFixed(1)}`);
            }
            
            // Apply predicted position to sprite
            if (playerSprites[myPlayerId]) {
                const yOffset = playerSprites[myPlayerId].characterYOffset || 0;
                playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y + yOffset); // Add 200px offset + character offset
                updateLocalPlayerHealthBar();
            }
        }
        
        function validateClientJump(currentTime) {
            if (!clientPlayerState || clientPlayerState.health <= 0) return false;
            if (clientPlayerState.jumpsRemaining <= 0) return false;
            if (currentTime - clientPlayerState.lastJumpTime < 250) return false; // Increased cooldown
            
            // Prevent impossible jumps - if falling too fast, deny jump
            if (clientPlayerState.velocityY > 300) return false;
            
            return true;
        }
        
        function performClientJump(currentTime) {
            const jumpVelocity = clientPlayerState.jumpsRemaining === 2 ? 
                PHYSICS_CONSTANTS.JUMP_VELOCITY_SINGLE : 
                PHYSICS_CONSTANTS.JUMP_VELOCITY_DOUBLE;
            
            clientPlayerState.velocityY = jumpVelocity;
            clientPlayerState.jumpsRemaining--;
            clientPlayerState.isGrounded = false;
            clientPlayerState.lastJumpTime = currentTime;
        }
        
        function validateClientDash(currentTime) {
            if (!clientPlayerState || clientPlayerState.health <= 0) return false;
            if (dashInputCooldown > 0) return false; // Prevent multiple dash triggers
            if (clientPlayerState.isDashing) return false; // Prevent dash while already dashing
            if (currentTime - (clientPlayerState.lastDashTime || 0) < 350) return false; // Dash cooldown (reduced from 500)
            return true;
        }

        function performClientDash(direction, currentTime) {
            const dashDirection = direction === 'left' ? -1 : 1;
            
            // Apply dash physics immediately
            clientPlayerState.isDashing = true;
            clientPlayerState.dashDirection = dashDirection;
            clientPlayerState.dashStartTime = currentTime;
            clientPlayerState.lastDashTime = currentTime;
            clientPlayerState.dashVelocity = DASH_VELOCITY * dashDirection;
            
            // Apply immediate velocity boost for responsive feel
            // clientPlayerState.velocityX += clientPlayerState.dashVelocity;
            
            // Apply movement immediately  
            const deltaTime = 1 / PHYSICS_CONSTANTS.FRAME_RATE;
            clientPlayerState.x += clientPlayerState.dashVelocity * deltaTime;
            
            // Update sprite position immediately
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                updateLocalPlayerHealthBar();
            }
            
                             // Client dash prediction applied
        }
        
        function bufferInput(inputs) {
            // Store input with timestamp for server reconciliation
            inputBuffer.push({
                inputs: { ...inputs },
                timestamp: Date.now(),
                clientState: { ...clientPlayerState }
            });
            
            // Keep buffer size manageable (last 1 second of inputs)
            const oneSecondAgo = Date.now() - 1000;
            inputBuffer = inputBuffer.filter(entry => entry.timestamp > oneSecondAgo);
        }
        
        function reconcileWithServer(serverState) {
            if (!clientPlayerState || !predictionEnabled) return;
            
            const serverPlayer = serverState.players[myPlayerId];
            if (!serverPlayer) return;
            
            // Handle edge cases: player death, elimination, or major state changes
            if (serverPlayer.isDead || serverPlayer.eliminated || serverPlayer.health <= 0) {
                // Force sync to server state for edge cases to prevent large errors
                clientPlayerState.x = serverPlayer.x;
                clientPlayerState.y = serverPlayer.y;
                clientPlayerState.velocityX = serverPlayer.velocityX || 0;
                clientPlayerState.velocityY = serverPlayer.velocityY || 0;
                clientPlayerState.isGrounded = serverPlayer.isGrounded;
                clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
                clientPlayerState.health = serverPlayer.health;
                
                if (playerSprites[myPlayerId]) {
                    const yOffset = playerSprites[myPlayerId].characterYOffset || 0;
                    playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y + yOffset);
                    updateLocalPlayerHealthBar();
                }
                
                lastServerUpdate = Date.now();
                updateDebugPanel();
                return;
            }
            
            // Calculate position difference
            const positionError = Math.sqrt(
                Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                Math.pow(clientPlayerState.y - serverPlayer.y, 2)
            );
            
            // ENHANCED DEBUGGING: Log the actual differences
            const xDiff = Math.abs(clientPlayerState.x - serverPlayer.x);
            const yDiff = Math.abs(clientPlayerState.y - serverPlayer.y);
            
            // Log significant differences even if they're in "dead zone"
            if (positionError > 5) {
                console.log(`[POSITION DEBUG] Total Error: ${positionError.toFixed(1)}px | X diff: ${xDiff.toFixed(1)}px | Y diff: ${yDiff.toFixed(1)}px | Client: (${clientPlayerState.x.toFixed(1)}, ${clientPlayerState.y.toFixed(1)}) | Server: (${serverPlayer.x.toFixed(1)}, ${serverPlayer.y.toFixed(1)})`);
            }
            
            // JUMP STATE ANALYSIS: Detect if we're in a jump scenario
            const now = Date.now();
            const recentJump = (now - clientPlayerState.lastJumpTime) < 800; // 800ms jump window
            const isClientAirborne = !clientPlayerState.isGrounded && clientPlayerState.velocityY < 100;
            const isServerGrounded = serverPlayer.isGrounded;
            const jumpDisagreement = isClientAirborne && isServerGrounded && recentJump;
            
            // LATENCY-AWARE THRESHOLDS: Adjust based on measured latency
            const latencyElement = document.getElementById('latency');
            const currentLatency = latencyElement ? parseInt(latencyElement.textContent) : 100;
            const latencyMultiplier = Math.max(1, currentLatency / 50); // Scale thresholds based on latency
            
            const DEAD_ZONE = Math.min(8 * latencyMultiplier, 15); // Scale with latency, max 15px
            const ERROR_THRESHOLD = Math.min(25 * latencyMultiplier, 40); // Scale with latency, max 40px
            const LARGE_ERROR_THRESHOLD = Math.min(60 * latencyMultiplier, 100); // Scale with latency, max 100px
            
            let correctionApplied = false;
            
            if (positionError < DEAD_ZONE) {
                // Within dead zone - no correction needed
                correctionApplied = false;
            } else if (jumpDisagreement && yDiff > 20) {
                // JUMP JITTER PREVENTION: During jump disagreements, be very conservative
                console.log(`[JUMP RECONCILE] Jump disagreement detected - client airborne, server grounded. Delaying correction. Y diff: ${yDiff.toFixed(1)}px`);
                correctionApplied = false; // Skip correction to prevent jitter
            } else {
                // Extra conservative during active movement to prevent jitter
                const isFalling = clientPlayerState.velocityY > 200 && !clientPlayerState.isGrounded;
                const justJumped = (Date.now() - clientPlayerState.lastJumpTime) < 500; // 500ms after jump
                
                if ((isFalling || justJumped) && positionError < ERROR_THRESHOLD * 1.5) {
                    // During falls or recent jumps, be extra conservative with corrections
                    correctionApplied = false;
                    console.log(`[PREDICTION] Skipping correction during movement - falling: ${isFalling}, justJumped: ${justJumped}, error: ${positionError.toFixed(1)}px`);
                } else {
                    correctionApplied = true;
                }
            }
            
            // Conservative correction factors to prevent oscillation
            let correctionFactor = 0;
            
            if (correctionApplied) {
                if (positionError > LARGE_ERROR_THRESHOLD) {
                    // Large error - use gentle correction to avoid snapping
                    correctionFactor = jumpDisagreement ? 0.1 : 0.3; // Much gentler during jump disagreements
                    console.log(`[PREDICTION] Large correction applied: ${positionError.toFixed(1)}px with factor ${correctionFactor} (jump disagreement: ${jumpDisagreement})`);
                } else if (positionError > ERROR_THRESHOLD) {
                    // Medium error - very gentle correction
                    correctionFactor = jumpDisagreement ? 0.05 : 0.15; // Much gentler during jump disagreements
                    console.log(`[PREDICTION] Medium correction applied: ${positionError.toFixed(1)}px with factor ${correctionFactor} (jump disagreement: ${jumpDisagreement})`);
                }
            }
            
            // Apply correction only if needed
            if (correctionFactor > 0) {
                // Store old position for debugging
                const oldX = clientPlayerState.x;
                const oldY = clientPlayerState.y;
                
                // Smooth interpolation towards server position
                clientPlayerState.x += (serverPlayer.x - clientPlayerState.x) * correctionFactor;
                clientPlayerState.y += (serverPlayer.y - clientPlayerState.y) * correctionFactor;
                
                console.log(`[CORRECTION] Applied: (${oldX.toFixed(1)}, ${oldY.toFixed(1)}) -> (${clientPlayerState.x.toFixed(1)}, ${clientPlayerState.y.toFixed(1)})`);
                
                // Gentle velocity sync only for large errors and no jump disagreement
                if (positionError > LARGE_ERROR_THRESHOLD && !jumpDisagreement) {
                    clientPlayerState.velocityX = serverPlayer.velocityX || 0;
                    clientPlayerState.velocityY = serverPlayer.velocityY || 0;
                }
                
                // Apply corrected position to sprite (only update if change is significant)
                if (playerSprites[myPlayerId]) {
                    const currentSpriteX = playerSprites[myPlayerId].x - 200;
                    const currentSpriteY = playerSprites[myPlayerId].y;
                    const changeThreshold = 2; // Only update sprite for changes > 2px
                    
                    if (Math.abs(currentSpriteX - clientPlayerState.x) > changeThreshold || 
                        Math.abs(currentSpriteY - clientPlayerState.y) > changeThreshold) {
                        const yOffset = playerSprites[myPlayerId].characterYOffset || 0;
                        playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y + yOffset);
                        updateLocalPlayerHealthBar();
                    }
                }
            }
            
            // IMPROVED GROUND STATE SYNC: Be more conservative about overriding grounded state
            const groundStateDisagreement = clientPlayerState.isGrounded !== serverPlayer.isGrounded;
            
            if (groundStateDisagreement) {
                if (serverPlayer.isGrounded && !clientPlayerState.isGrounded) {
                    // Server says grounded, client says airborne
                    if (!recentJump || yDiff < 15) {
                        // Only sync if no recent jump OR very small Y difference
                        console.log(`[GROUND SYNC] Server says grounded, syncing client (recentJump: ${recentJump}, yDiff: ${yDiff.toFixed(1)})`);
                        clientPlayerState.isGrounded = true;
                        clientPlayerState.jumpsRemaining = 2;
                        clientPlayerState.velocityY = 0;
                    } else {
                        console.log(`[GROUND SYNC] Skipping ground sync due to recent jump (${(now - clientPlayerState.lastJumpTime)}ms ago)`);
                    }
                } else if (!serverPlayer.isGrounded && clientPlayerState.isGrounded) {
                    // Server says airborne, client says grounded - trust server immediately
                    console.log(`[GROUND SYNC] Server says airborne, syncing client`);
                    clientPlayerState.isGrounded = false;
                }
            }
            
            // Always sync other critical state
            clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
            clientPlayerState.health = serverPlayer.health;
            
            // Update correction status indicator
            const correctionStatusEl = document.getElementById('correction-status');
            if (correctionStatusEl) {
                if (!correctionApplied) {
                    if (positionError < DEAD_ZONE) {
                        correctionStatusEl.textContent = '(dead zone)';
                        correctionStatusEl.style.color = '#FF8C42';
                    } else if (jumpDisagreement) {
                        correctionStatusEl.textContent = '(jump delay)';
                        correctionStatusEl.style.color = '#ffff00';
                    } else {
                        correctionStatusEl.textContent = '(skipped)';
                        correctionStatusEl.style.color = '#ffff66';
                    }
                } else {
                    correctionStatusEl.textContent = '(corrected)';
                    correctionStatusEl.style.color = '#ff9966';
                }
            }
            
            lastServerUpdate = Date.now();
            
            // Always update debug panel with current error info
            updateDebugPanel();
        }
        
        let lastDebugUpdate = 0;
        const DEBUG_UPDATE_INTERVAL = 300; // Update debug panel only every 300ms for better performance
        
        function updateDebugPanel() {
            const now = Date.now();
            if (now - lastDebugUpdate < DEBUG_UPDATE_INTERVAL) return;
            lastDebugUpdate = now;
            
            const predictionStatusEl = document.getElementById('prediction-status');
            predictionStatusEl.textContent = predictionEnabled ? 'ON' : 'OFF';
            predictionStatusEl.style.color = predictionEnabled ? '#FF8C42' : '#ff6666';
            document.getElementById('buffer-size').textContent = inputBuffer.length;
            document.getElementById('server-time').textContent = (now - lastServerUpdate).toFixed(0) + 'ms ago';
            
            // Enhanced position error tracking for high latency debugging
            if (predictionEnabled && clientPlayerState && gameState.players[myPlayerId]) {
                const serverPlayer = gameState.players[myPlayerId];
                const positionError = Math.sqrt(
                    Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                    Math.pow(clientPlayerState.y - serverPlayer.y, 2)
                );
                
                // Calculate individual axis errors
                const xError = Math.abs(clientPlayerState.x - serverPlayer.x);
                const yError = Math.abs(clientPlayerState.y - serverPlayer.y);
                
                // Calculate velocity error for debug display
                const serverVelX = serverPlayer.velocityX || 0;
                const serverVelY = serverPlayer.velocityY || 0;
                const velocityError = Math.sqrt(
                    Math.pow(clientPlayerState.velocityX - serverVelX, 2) + 
                    Math.pow(clientPlayerState.velocityY - serverVelY, 2)
                );
                
                // Enhanced error display with color coding
                let errorText = `${positionError.toFixed(1)}px (X:${xError.toFixed(1)} Y:${yError.toFixed(1)})`;
                let errorColor = '#FF8C42'; // Orange for good
                
                if (positionError > 40) {
                    errorColor = '#ff6666'; // Red for bad
                    errorText += ` HIGH!`;
                } else if (positionError > 25) {
                    errorColor = '#ff9966'; // Orange for concerning
                    errorText += ` (high)`;
                } else if (positionError > 15) {
                    errorColor = '#ffff66'; // Yellow for moderate
                } else if (positionError > 5) {
                    errorColor = '#66ffff'; // Cyan for minor
                }
                
                const errorElement = document.getElementById('position-error');
                errorElement.textContent = errorText;
                errorElement.style.color = errorColor;
                
                // Update status to show actual positions if error is high
                if (positionError > 15) {
                    const statusText = `Client:(${clientPlayerState.x.toFixed(0)},${clientPlayerState.y.toFixed(0)}) Server:(${serverPlayer.x.toFixed(0)},${serverPlayer.y.toFixed(0)})`;
                    document.getElementById('input-status').textContent = statusText;
                    document.getElementById('input-status').style.fontSize = '10px';
                }
                
                // Show server tick rate if available
                if (gameState.tickRate) {
                    const tickElement = document.getElementById('server-tickrate');
                    if (tickElement) {
                        tickElement.textContent = `${gameState.tickRate}fps (sync'd)`;
                        tickElement.style.color = PHYSICS_CONSTANTS.FRAME_RATE === gameState.tickRate ? '#FF8C42' : '#ff9966';
                    }
                }
            } else {
                document.getElementById('position-error').textContent = '0.0';
                document.getElementById('position-error').style.color = '#FF8C42';
            }
        }
        
        function handleJumpEvent(jumpEvent) {
            // Handle jump event for visual effects (particle effects, sound, etc.)
            const playerSprite = playerSprites[jumpEvent.playerId];
            if (!playerSprite) return;
            
            // Visual feedback for jumps
            const jumpEffect = this.add.circle(jumpEvent.position.x + 200, jumpEvent.position.y + 30, 15, 0xFFFF00, 0.7);
            jumpEffect.setDepth(1000); // Render on top
            
            // Animate the effect
            this.tweens.add({
                targets: jumpEffect,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 300,
                ease: 'Power2',
                onComplete: () => {
                    jumpEffect.destroy();
                }
            });
            
            // Different effects for single vs double jump
            if (jumpEvent.jumpType === 'double') {
                // Add sparkle effect for double jump
                const sparkle = this.add.circle(jumpEvent.position.x + 200, jumpEvent.position.y + 25, 8, 0xFF00FF, 0.9);
                sparkle.setDepth(1001);
                
                this.tweens.add({
                    targets: sparkle,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    alpha: 0,
                    duration: 200,
                    ease: 'Power1',
                    onComplete: () => sparkle.destroy()
                });
            }
        }
        
        function handleDashEvent(dashEvent) {
            // Handle dash event for visual effects (particle trail, sound, etc.)
            const playerSprite = playerSprites[dashEvent.playerId];
            if (!playerSprite) return;
            
            // Visual feedback for dash - create trail effect
            const dashTrail = this.add.rectangle(
                dashEvent.position.x + 200, 
                dashEvent.position.y, 
                60, 
                20, 
                0x00FFFF, 
                0.6
            );
            dashTrail.setDepth(999); // Render behind player but above background
            
            // Animate the trail effect
            this.tweens.add({
                targets: dashTrail,
                scaleX: dashEvent.direction === 'left' ? -0.2 : 0.2,
                scaleY: 0.5,
                alpha: 0,
                duration: 200,
                ease: 'Power2',
                onComplete: () => {
                    dashTrail.destroy();
                }
            });
            
            // Add directional speed lines
            for (let i = 0; i < 3; i++) {
                const speedLine = this.add.rectangle(
                    dashEvent.position.x + 200 + (dashEvent.direction === 'left' ? 20 : -20) * (i + 1), // Add 200px offset
                    dashEvent.position.y + (Math.random() - 0.5) * 30,
                    15,
                    3,
                    0xFFFFFF,
                    0.8
                );
                speedLine.setDepth(998);
                
                this.tweens.add({
                    targets: speedLine,
                    x: speedLine.x + (dashEvent.direction === 'left' ? -30 : 30),
                    alpha: 0,
                    duration: 150 + i * 50,
                    ease: 'Linear',
                    onComplete: () => speedLine.destroy()
                });
            }
            
            console.log(`Dash visual effect for player ${dashEvent.playerId} direction ${dashEvent.direction}`);
        }
        
        function handleDashInterruption(interruptEvent) {
            // Handle dash interruption for visual effects cleanup
            const playerSprite = playerSprites[interruptEvent.playerId];
            if (!playerSprite) return;
            
            // Clean up any active dash visual effects
            this.children.getChildren().forEach(child => {
                if (child.name && (child.name.includes('dashTrail') || child.name.includes('speedLine'))) {
                    child.destroy();
                }
            });
            
            // Visual feedback for dash interruption (brief flash effect)
            if (playerSprite) {
                this.tweens.add({
                    targets: playerSprite,
                    alpha: 0.5,
                    duration: 100,
                    yoyo: true,
                    ease: 'Power2'
                });
            }
            
            console.log(`Dash interrupted for player ${interruptEvent.playerId}: ${interruptEvent.reason}`);
        }
        
        function handlePlayerDeath(deathEvent) {
            console.log(`Player ${deathEvent.playerId} died! Lives remaining: ${deathEvent.livesRemaining}`);
            
            // Create death effect at death position
            const deathEffect = this.add.circle(deathEvent.deathPosition.x + 200, deathEvent.deathPosition.y, 50, 0xff0000, 0.8);
            deathEffect.setDepth(1000);
            
            // Animate death effect
            this.tweens.add({
                targets: deathEffect,
                scaleX: 3,
                scaleY: 3,
                alpha: 0,
                duration: 500,
                ease: 'Power2',
                onComplete: () => deathEffect.destroy()
            });
            
            // Handle local player death with countdown and fade effects
            if (deathEvent.playerId === myPlayerId && !deathEvent.isEliminated) {
                // Screen shake for local player death
                this.cameras.main.shake(300, 0.02);
                
                // Start fade effect on player sprite
                if (playerSprites[myPlayerId]) {
                    this.tweens.add({
                        targets: playerSprites[myPlayerId],
                        alpha: 0.2,
                        duration: 3000, // Fade over 3 seconds
                        ease: 'Linear'
                    });
                }
                
                // Start respawn countdown
                startRespawnCountdown();
            }
            
            // For other players, just fade their sprite
            if (deathEvent.playerId !== myPlayerId && playerSprites[deathEvent.playerId]) {
                this.tweens.add({
                    targets: playerSprites[deathEvent.playerId],
                    alpha: 0.3,
                    duration: 1000,
                    ease: 'Power2'
                });
            }
        }
        
        function startRespawnCountdown() {
            const countdownElement = document.getElementById('respawn-countdown');
            let timeLeft = 3;
            
            function updateCountdown() {
                if (timeLeft > 0) {
                    countdownElement.textContent = timeLeft;
                    countdownElement.style.display = 'block';
                    
                    // Pulse effect for countdown
                    countdownElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        countdownElement.style.transform = 'translate(-50%, -50%) scale(1.0)';
                    }, 200);
                    
                    timeLeft--;
                    setTimeout(updateCountdown, 1000);
                } else {
                    countdownElement.style.display = 'none';
                }
            }
            
            updateCountdown();
        }
        
        function handlePlayerRespawn(respawnEvent) {
            console.log(`Player ${respawnEvent.playerId} respawned with invincibility`);
            
            // Restore sprite alpha for respawned player
            if (playerSprites[respawnEvent.playerId]) {
                // Stop any existing fade tweens
                this.tweens.killTweensOf(playerSprites[respawnEvent.playerId]);
                // Restore full alpha
                playerSprites[respawnEvent.playerId].setAlpha(1.0);
            }
            
            // Create respawn effect
            const respawnEffect = this.add.circle(respawnEvent.position.x + 200, respawnEvent.position.y, 30, 0x00ffff, 0.7);
            respawnEffect.setDepth(1000);
            
            // Animate respawn effect
            this.tweens.add({
                targets: respawnEffect,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => respawnEffect.destroy()
            });
            
            // Add sparkle effects
            for (let i = 0; i < 8; i++) {
                const sparkle = this.add.circle(
                    respawnEvent.position.x + 200 + (Math.random() - 0.5) * 60, // Add 200px offset
                    respawnEvent.position.y + (Math.random() - 0.5) * 60,
                    3,
                    0xffffff,
                    0.9
                );
                sparkle.setDepth(1001);
                
                this.tweens.add({
                    targets: sparkle,
                    scaleX: 2,
                    scaleY: 2,
                    alpha: 0,
                    duration: 300 + Math.random() * 200,
                    ease: 'Power1',
                    onComplete: () => sparkle.destroy()
                });
            }
            
            // Hide countdown for local player
            if (respawnEvent.playerId === myPlayerId) {
                const countdownElement = document.getElementById('respawn-countdown');
                countdownElement.style.display = 'none';
            }
        }
        
        function handlePlayerElimination(eliminationEvent) {
            console.log(`Player ${eliminationEvent.playerId} eliminated!`);
            
            // Create elimination effect
            const eliminationEffect = this.add.circle(eliminationEvent.finalPosition.x + 200, eliminationEvent.finalPosition.y, 80, 0xff6600, 0.9);
            eliminationEffect.setDepth(1000);
            
            // Animate elimination effect
            this.tweens.add({
                targets: eliminationEffect,
                scaleX: 4,
                scaleY: 4,
                alpha: 0,
                duration: 800,
                ease: 'Power3',
                onComplete: () => eliminationEffect.destroy()
            });
            
            // Add text effect
            const eliminationText = this.add.text(eliminationEvent.finalPosition.x + 200, eliminationEvent.finalPosition.y - 50, 'ELIMINATED!', {
                fontSize: '24px',
                fill: '#ff6600',
                stroke: '#000000',
                strokeThickness: 2
            });
            eliminationText.setOrigin(0.5);
            eliminationText.setDepth(1001);
            
            this.tweens.add({
                targets: eliminationText,
                y: eliminationText.y - 100,
                alpha: 0,
                duration: 1000,
                ease: 'Power2',
                onComplete: () => eliminationText.destroy()
            });
        }
        
        function handleMatchEnd(matchEndEvent) {
            console.log(`Match ended! Winner: ${matchEndEvent.winnerId}`);
            
            // Create match end overlay
            const overlay = this.add.rectangle(600, 500, 1200, 1000, 0x000000, 0.7); // Expanded to 1200x1000, centered at (600, 500)
            overlay.setDepth(2000);
            
            // Winner text
            const winnerText = matchEndEvent.winnerId === myPlayerId ? 'YOU WIN!' : 
                              matchEndEvent.winnerId ? 'MATCH OVER' : 'DRAW!';
            const winnerColor = matchEndEvent.winnerId === myPlayerId ? '#F36D32' : '#ffffff';
            
            const matchEndText = this.add.text(600, 400, winnerText, { // Centered at 600 for 1200px canvas
                fontSize: '48px',
                fill: winnerColor,
                stroke: '#000000',
                strokeThickness: 3
            });
            matchEndText.setOrigin(0.5);
            matchEndText.setDepth(2001);
            
            // Final standings text
            let standingsText = 'Final Standings:\n';
            matchEndEvent.finalStandings.forEach((standing, index) => {
                const position = index + 1;
                const playerText = standing.playerId === myPlayerId ? 'YOU' : `Player ${standing.playerId.slice(-4)}`;
                standingsText += `${position}. ${playerText} - ${standing.lives} lives\n`;
            });
            
            const standingsDisplay = this.add.text(600, 550, standingsText, { // Centered at 600 for 1200px canvas
                fontSize: '18px',
                fill: '#ffffff',
                align: 'center'
            });
            standingsDisplay.setOrigin(0.5);
            standingsDisplay.setDepth(2001);
            
            // Store overlay elements for cleanup
            this.matchEndOverlay = [overlay, matchEndText, standingsDisplay];
        }
        
        function handleMatchReset(resetEvent) {
            console.log('Match reset - new round starting!');
            
            // Clean up match end overlay
            if (this.matchEndOverlay) {
                this.matchEndOverlay.forEach(element => element.destroy());
                this.matchEndOverlay = null;
            }
            
            // Create new round announcement
            const newRoundText = this.add.text(600, 500, 'NEW ROUND!', { // Centered at 600 for 1200px canvas
                fontSize: '36px',
                fill: '#ffff00',
                stroke: '#000000',
                strokeThickness: 2
            });
            newRoundText.setOrigin(0.5);
            newRoundText.setDepth(1000);
            
            // Animate and remove announcement
            this.tweens.add({
                targets: newRoundText,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 2000,
                ease: 'Power2',
                onComplete: () => newRoundText.destroy()
            });
        }
        
        function handleInvincibilityEnd(invincibilityEvent) {
            console.log(`Player ${invincibilityEvent.playerId} invincibility ended`);
            
            // Visual feedback for invincibility ending (small flash effect)
            if (playerSprites[invincibilityEvent.playerId]) {
                const player = playerSprites[invincibilityEvent.playerId];
                this.tweens.add({
                    targets: player,
                    alpha: 0.3,
                    duration: 100,
                    yoyo: true,
                    repeat: 2,
                    ease: 'Power1'
                });
            }
        }
        
        // Game Over Functions
        function showGameOverScreen(gameOverData) {
            console.log('Showing game over screen:', gameOverData);
            
            // Update winner text
            winnerText.textContent = gameOverData.winnerId ? 
                `🏆 Winner: ${gameOverData.winnerName}` : 
                '🤝 Draw - No Winner';
            
            // Clear and populate stats table
            statsTbody.innerHTML = '';
            
            // Track numerical rank for non-DQ players
            let numericalRank = 1;
            
            gameOverData.playerStats.forEach((player, index) => {
                const row = document.createElement('tr');
                
                // Add special classes for winner, current player, and disconnected
                if (player.isWinner) {
                    row.classList.add('winner');
                }
                if (player.playerId === socket.id) {
                    row.classList.add('current-player');
                }
                if (player.disconnected) {
                    row.classList.add('disconnected');
                }
                
                // Display rank as DQ for disconnected players, otherwise show numerical position
                const rank = player.disconnected ? 'DQ' : `#${numericalRank}`;
                if (!player.disconnected) {
                    numericalRank++;
                }
                
                const playerDisplayName = player.playerName + (player.playerId === socket.id ? ' (You)' : '') + (player.disconnected ? ' [DISCONNECTED]' : '');
                
                row.innerHTML = `
                    <td>${rank}</td>
                    <td>${playerDisplayName}</td>
                    <td>${player.kills}</td>
                    <td>${player.deaths}</td>
                    <td>${player.kdr}</td>
                `;
                
                statsTbody.appendChild(row);
            });
            
            // Show/hide rematch button based on host status AND player count
            const activePlayers = gameOverData.playerStats.filter(player => !player.disconnected);
            const canRematch = isHost && activePlayers.length >= 2;
            
            console.log(`Rematch check - isHost: ${isHost}, activePlayers: ${activePlayers.length}, canRematch: ${canRematch}`);
            
            rematchBtn.style.display = canRematch ? 'block' : 'none';
            
            if (!canRematch && isHost && activePlayers.length < 2) {
                console.log('Rematch not available - need at least 2 active players');
            }
            
            // Show the game over screen
            gameOverScreen.style.display = 'block';
        }
        
        function hideGameOverScreen() {
            gameOverScreen.style.display = 'none';
        }
        
        function handleRematch() {
            if (!isHost) {
                showMessage('Only the host can start a rematch', 'error');
                return;
            }
            
            // Disable button to prevent multiple clicks
            rematchBtn.disabled = true;
            rematchBtn.textContent = 'Starting Rematch...';
            
            socket.emit('rematch', (response) => {
                if (response.success) {
                    hideGameOverScreen();
                    showMessage('Rematch starting!', 'success');
                } else {
                    showMessage(response.error, 'error');
                    // Re-enable button on error
                    rematchBtn.disabled = false;
                    rematchBtn.textContent = 'Rematch';
                }
            });
        }
        
        function handleReturnToLobby() {
            socket.emit('returnToLobby', (response) => {
                if (response.success) {
                    hideGameOverScreen();
                    // Show room UI again
                    roomUI.style.display = 'block';
                    showRoomLobby(currentRoom.code, isHost);
                    showMessage('Returned to lobby', 'success');
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
    </script>
</body>
</html> 