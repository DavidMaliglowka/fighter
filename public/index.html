<!DOCTYPE html>
<html>
<head>
    <title>Fighter Game</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="platforms.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            /* Removed border and border-radius for cleaner look */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 1000;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 1000;
        }
        #respawn-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ff6666;
            padding: 30px;
            border-radius: 15px;
            font-size: 64px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 2000;
            border: 3px solid #ff6666;
            box-shadow: 0 0 30px rgba(255, 102, 102, 0.5);
        }
        
        /* Game Start Countdown */
        #game-start-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #4CAF50;
            padding: 40px;
            border-radius: 20px;
            font-size: 72px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 3000;
            border: 4px solid #4CAF50;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.6);
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        
        #game-start-countdown .countdown-text {
            font-size: 28px;
            margin-bottom: 10px;
            color: #81C784;
        }
        
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* Room Management UI Styles */
        #room-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 1500;
            border: 2px solid #4CAF50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.3);
            font-family: Arial, sans-serif;
            min-width: 400px;
        }
        
        #room-ui h1 {
            margin: 0 0 30px 0;
            color: #4CAF50;
            font-size: 36px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        #room-ui h2 {
            margin: 20px 0 15px 0;
            color: #ffffff;
            font-size: 24px;
        }
        
        .room-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .room-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .room-button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .room-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .room-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4CAF50;
            color: white;
            padding: 12px 20px;
            font-size: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 10px;
            width: 120px;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        
        .room-input:focus {
            outline: none;
            border-color: #66BB6A;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        #room-code-display {
            font-size: 48px;
            font-weight: bold;
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            padding: 20px;
            border-radius: 15px;
            letter-spacing: 8px;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            border: 2px solid #4CAF50;
            margin: 20px 0;
        }
        
        #player-list {
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .player-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .player-host {
            background: rgba(76, 175, 80, 0.2);
            border-left: 4px solid #4CAF50;
        }
        
        .error-message {
            color: #f44336;
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid #f44336;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .success-message {
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        #room-ui.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="player-count">Players: 0</div>
        <div id="health">Health: 100</div>
        <div id="lives">Lives: 3</div>
        <div id="match-status"></div>
    </div>
    
    <!-- Room Management UI -->
    <div id="room-ui">
        <h1>🥊 Fighter Game</h1>
        
        <!-- Main Menu (when not in room) -->
        <div id="main-menu">
            <div class="room-section">
                <h2>Create a New Game</h2>
                <button id="create-room-btn" class="room-button">Create Room</button>
                <p style="color: #aaa; font-size: 14px;">Share the room code with friends!</p>
            </div>
            
            <div class="room-section">
                <h2>Join a Game</h2>
                <input type="text" id="room-code-input" class="room-input" placeholder="ROOM" maxlength="4" />
                <br>
                <button id="join-room-btn" class="room-button">Join Room</button>
            </div>
        </div>
        
        <!-- Room Lobby (when in room) -->
        <div id="room-lobby" style="display: none;">
            <h2>Room Code</h2>
            <div id="room-code-display">ABCD</div>
            <p style="color: #aaa;">Share this code with your friends!</p>
            
            <div class="room-section">
                <h2>Players (<span id="room-player-count">1</span>/8)</h2>
                <div id="player-list">
                    <!-- Players will be added here dynamically -->
                </div>
            </div>
            
            <div class="room-section">
                <button id="start-game-btn" class="room-button" style="display: none;">Start Game</button>
                <button id="leave-room-btn" class="room-button" style="background: #f44336;">Leave Room</button>
            </div>
        </div>
        
        <!-- Messages -->
        <div id="room-messages"></div>
    </div>
    
    <div id="game-container"></div>
    <div id="respawn-countdown"></div>
    
    <!-- Game Start Countdown -->
    <div id="game-start-countdown">
        <div class="countdown-text">Game Starting...</div>
        <div class="countdown-number">3</div>
    </div>
    
    <div id="controls">
        <div>Controls:</div>
        <div>Left/Right: Move</div>
        <div>Up: Jump</div>
        <div>Down: Drop through platforms</div>
        <div>Space: Attack</div>
        <div>Z: Block</div>
        <div>Shift+Arrow: Dash</div>
        <div>Double-tap Arrow: Dash</div>
        <div>P: Toggle Prediction</div>
    </div>
    
    <div id="prediction-debug" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px;">
        <div>Prediction: <span id="prediction-status">ON</span></div>
        <div>Position Error: <span id="position-error">0.0</span>px</div>
        <div>Buffer Size: <span id="buffer-size">0</span></div>
        <div>Last Update: <span id="last-update">0</span>ms ago</div>
        <div>Input Status: <span id="input-status">Normal</span></div>
    </div>
    
    <script>
        // Phaser game configuration
        const config = {
            type: Phaser.AUTO,
            width: 1200, // Expanded from 800 to allow fall-off movement
            height: 1000, // Expanded from 600 to allow fall recovery attempts
            parent: 'game-container',
            backgroundColor: '#2c5f2d',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 }, // Server handles gravity
                    debug: false // Server handles collision detection
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // Create the game
        const game = new Phaser.Game(config);

        let cursors;
        let socket;
        let spaceKey;
        let zKey;
        let shiftKey; // Dedicated dash key
        let platforms; // Platform physics group
        
        // Dash input detection variables
        let lastLeftKeyTime = 0;
        let lastRightKeyTime = 0;
        let dashInputCooldown = 0; // Prevent multiple dash triggers
        const DASH_DOUBLE_TAP_WINDOW = 250; // ms
        const DASH_INPUT_COOLDOWN = 100; // ms to prevent multiple triggers
        
        const playerSprites = {};
        const playerHealthBars = {};
        const playerAttackEffects = {};
        let myPlayerId = null;
        let gameState = { players: {} };
        
        // Client-side prediction variables
        let clientPlayerState = null;
        let inputBuffer = [];
        let lastServerUpdate = 0;
        let predictionEnabled = true;
        const PHYSICS_CONSTANTS = {
            GRAVITY: 800,
            GROUND_Y: 560,
            FRAME_RATE: 60,
            JUMP_VELOCITY_SINGLE: -500,
            JUMP_VELOCITY_DOUBLE: -400
        };

        // ==================== ROOM MANAGEMENT SYSTEM ====================
        
        // Room management variables
        let currentRoom = null;
        let isHost = false;
        let gameStarted = false;
        
        // Room UI Elements
        const roomUI = document.getElementById('room-ui');
        const mainMenu = document.getElementById('main-menu');
        const roomLobby = document.getElementById('room-lobby');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const roomCodeInput = document.getElementById('room-code-input');
        const roomCodeDisplay = document.getElementById('room-code-display');
        const playerList = document.getElementById('player-list');
        const playerCount = document.getElementById('room-player-count');
        const startGameBtn = document.getElementById('start-game-btn');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const roomMessages = document.getElementById('room-messages');
        
        // Room management functions
        function showMessage(message, type = 'info') {
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.textContent = message;
            roomMessages.appendChild(messageDiv);
            
            // Auto-remove message after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }
        
        function showMainMenu() {
            mainMenu.style.display = 'block';
            roomLobby.style.display = 'none';
            roomUI.classList.remove('hidden');
            gameStarted = false;
        }
        
        function showRoomLobby(roomCode, hostStatus) {
            mainMenu.style.display = 'none';
            roomLobby.style.display = 'block';
            roomCodeDisplay.textContent = roomCode;
            isHost = hostStatus;
            
            // Show start button only for host
            startGameBtn.style.display = isHost ? 'block' : 'none';
        }
        
        function hideRoomUI() {
            roomUI.classList.add('hidden');
            gameStarted = true;
        }
        
        function updatePlayerList(players) {
            playerList.innerHTML = '';
            
            if (players && players.length > 0) {
                players.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-item';
                    if (player.isHost) {
                        playerDiv.classList.add('player-host');
                    }
                    
                    playerDiv.innerHTML = `
                        <span>Player ${player.socketId.substring(0, 8)}...</span>
                        <span>${player.isHost ? '👑 Host' : '🕹️ Player'}</span>
                    `;
                    
                    playerList.appendChild(playerDiv);
                });
                
                playerCount.textContent = players.length;
            } else {
                playerCount.textContent = '0';
            }
        }
        
        function createRoom() {
            if (!socket) {
                showMessage('Not connected to server', 'error');
                return;
            }
            
            createRoomBtn.disabled = true;
            createRoomBtn.textContent = 'Creating...';
            
            socket.emit('createRoom', (response) => {
                createRoomBtn.disabled = false;
                createRoomBtn.textContent = 'Create Room';
                
                if (response.success) {
                    currentRoom = {
                        code: response.roomCode,
                        isHost: response.isHost,
                        playerCount: response.playerCount
                    };
                    
                    showRoomLobby(response.roomCode, response.isHost);
                    showMessage(`Room ${response.roomCode} created successfully!`, 'success');
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        function joinRoom() {
            const roomCode = roomCodeInput.value.trim().toUpperCase();
            
            if (!roomCode || roomCode.length !== 4) {
                showMessage('Please enter a 4-letter room code', 'error');
                return;
            }
            
            if (!socket) {
                showMessage('Not connected to server', 'error');
                return;
            }
            
            joinRoomBtn.disabled = true;
            joinRoomBtn.textContent = 'Joining...';
            
            socket.emit('joinRoom', { roomCode }, (response) => {
                joinRoomBtn.disabled = false;
                joinRoomBtn.textContent = 'Join Room';
                
                if (response.success) {
                    currentRoom = {
                        code: response.roomCode,
                        isHost: response.isHost,
                        playerCount: response.playerCount
                    };
                    
                    showRoomLobby(response.roomCode, response.isHost);
                    showMessage(`Joined room ${response.roomCode}!`, 'success');
                    roomCodeInput.value = '';
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        function leaveRoom() {
            if (!socket || !currentRoom) return;
            
            socket.emit('leaveRoom', (response) => {
                if (response.success) {
                    currentRoom = null;
                    isHost = false;
                    showMainMenu();
                    showMessage('Left room successfully', 'success');
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        function startGame() {
            if (!isHost) {
                showMessage('Only the host can start the game', 'error');
                return;
            }
            
            // Disable the start button to prevent multiple clicks
            startGameBtn.disabled = true;
            startGameBtn.textContent = 'Starting...';
            
            // Emit startGame event to server
            socket.emit('startGame', (response) => {
                if (response.success) {
                    // Game start countdown will be handled by socket events
                    console.log('Game start initiated:', response.message);
                } else {
                    showMessage(response.error, 'error');
                    // Re-enable the button if there was an error
                    startGameBtn.disabled = false;
                    startGameBtn.textContent = 'Start Game';
                }
            });
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            createRoomBtn.addEventListener('click', createRoom);
            joinRoomBtn.addEventListener('click', joinRoom);
            leaveRoomBtn.addEventListener('click', leaveRoom);
            startGameBtn.addEventListener('click', startGame);
            
            // Handle Enter key in room code input
            roomCodeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    joinRoom();
                }
            });
            
            // Auto-uppercase room code input
            roomCodeInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase();
            });
        });
        
        // ==================== END ROOM MANAGEMENT SYSTEM ====================

        function preload() {
            // Create simple colored rectangles for sprites - extend background
            this.add.graphics()
                .fillStyle(0x333333)
                .fillRect(0, 0, 1200, 1000);
                
            // Removed play area outline for cleaner look
                
                // Removed death boundary line for cleaner look
                    
                // Bottom area now matches background - simple and clean
                this.add.graphics()
                    .fillStyle(0x333333) // Same grey as main background
                    .fillRect(0, 600, 1200, 400); // Fill entire bottom area with background color
        }

        // Platforms are now server-side only - no client collision callbacks needed

        function create() {
            // Create platform physics group (static - they don't move)
            platforms = this.physics.add.staticGroup();
            
            // Create all platforms from configuration
            if (window.PlatformConfig) {
                const { PLATFORMS, PLATFORM_COLORS } = window.PlatformConfig;
                
                PLATFORMS.forEach(platformData => {
                    // Create platform sprite with proper color
                    const color = PLATFORM_COLORS[platformData.type];
                    const platform = this.add.rectangle(
                        platformData.x + 200, // Offset by 200px to center in 1200px canvas
                        platformData.y,
                        platformData.width,
                        platformData.height,
                        color
                    );
                    
                    // Add physics body to the platform
                    platforms.add(platform);
                    
                    // Store platform data for collision detection
                    platform.platformData = platformData;
                });
                
                console.log(`Created ${PLATFORMS.length} platforms`);
            } else {
                console.error('Platform configuration not loaded!');
                // Fallback to original ground
                this.add.rectangle(400, 580, 800, 40, 0x8B4513);
            }
            
            // Background elements removed for cleaner look
            
            cursors = this.input.keyboard.createCursorKeys();
            spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            zKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
            
            // Dash input keys
            shiftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
            
            // Set camera bounds to show the full expanded area
            this.cameras.main.setBounds(0, 0, 1200, 1000);
            // Center camera on the main play area initially  
            this.cameras.main.setScroll(0, 0);
            
            // Store reference to scene for collision callbacks
            window.gameScene = this;
            
            // Prediction toggle key
            const pKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
            pKey.on('down', () => {
                predictionEnabled = !predictionEnabled;
                console.log(`Prediction toggled: ${predictionEnabled ? 'ON' : 'OFF'}`);
                if (!predictionEnabled) {
                    clientPlayerState = null; // Reset client state
                    console.log('Client state reset - prediction disabled');
                } else {
                    console.log('Prediction enabled - client state will reinitialize');
                }
                updateDebugPanel();
            });
            
            socket = io();
            myPlayerId = socket.id;
            
            socket.on('gameState', (newGameState) => {
                gameState = newGameState;
                
                // Client-side prediction reconciliation
                if (predictionEnabled && myPlayerId) {
                    reconcileWithServer(newGameState);
                }
                
                updatePlayerCount();
                updatePlayerSprites.call(this);
                updateUI();
            });
            
            socket.on('connect', () => {
                myPlayerId = socket.id;
            });
            
            // Listen for jump events for visual effects
            socket.on('playerJump', (jumpEvent) => {
                handleJumpEvent.call(this, jumpEvent);
            });
            
            // Listen for dash events for visual effects
            socket.on('playerDash', (dashEvent) => {
                handleDashEvent.call(this, dashEvent);
            });
            
            // Listen for death events
            socket.on('playerDeath', (deathEvent) => {
                handlePlayerDeath.call(this, deathEvent);
            });
            
            // Listen for respawn events
            socket.on('playerRespawn', (respawnEvent) => {
                handlePlayerRespawn.call(this, respawnEvent);
            });
            
            // Listen for elimination events
            socket.on('playerEliminated', (eliminationEvent) => {
                handlePlayerElimination.call(this, eliminationEvent);
            });
            
            // Listen for match end events
            socket.on('matchEnd', (matchEndEvent) => {
                handleMatchEnd.call(this, matchEndEvent);
            });
            
            // Listen for match reset events
            socket.on('matchReset', (resetEvent) => {
                handleMatchReset.call(this, resetEvent);
            });
            
            // Listen for invincibility end events
            socket.on('playerInvincibilityEnd', (invincibilityEvent) => {
                handleInvincibilityEnd.call(this, invincibilityEvent);
            });
            
            // ==================== ROOM EVENT HANDLERS ====================
            
            // Listen for new players joining the room
            socket.on('playerJoinedRoom', (event) => {
                if (currentRoom) {
                    showMessage(`Player joined the room (${event.playerCount}/8)`, 'success');
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                }
            });
            
            // Listen for players leaving the room
            socket.on('playerLeftRoom', (event) => {
                if (currentRoom) {
                    let message = `Player left the room (${event.playerCount}/8)`;
                    
                    if (event.reason === 'disconnect') {
                        message = `Player disconnected (${event.playerCount}/8)`;
                    }
                    
                    showMessage(message, 'info');
                    
                    // Update host status if needed
                    if (event.newHostId === socket.id) {
                        isHost = true;
                        startGameBtn.style.display = 'block';
                        showMessage('You are now the host!', 'success');
                    }
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                }
            });
            
            // Listen for room closure
            socket.on('roomClosed', (event) => {
                if (currentRoom && event.code === currentRoom.code) {
                    currentRoom = null;
                    isHost = false;
                    showMainMenu();
                    
                    let reason = 'Unknown reason';
                    if (event.reason === 'cleanup') {
                        reason = 'Room was inactive for too long';
                    }
                    
                    showMessage(`Room closed: ${reason}`, 'error');
                }
            });
            
            // Listen for room errors
            socket.on('roomError', (error) => {
                showMessage(error.message, 'error');
            });
            
            // ==================== GAME START EVENT HANDLERS ====================
            
            // Listen for game start countdown
            socket.on('gameStartCountdown', (event) => {
                console.log('Game start countdown:', event.countdown);
                
                const countdownEl = document.getElementById('game-start-countdown');
                const countdownNumberEl = countdownEl.querySelector('.countdown-number');
                
                // Show countdown with current number
                countdownNumberEl.textContent = event.countdown;
                countdownEl.style.display = 'block';
                
                // Play countdown sound effect (if available)
                // You could add audio here: new Audio('countdown.mp3').play();
            });
            
            // Listen for game started
            socket.on('gameStarted', (event) => {
                console.log('Game started!', event);
                
                const countdownEl = document.getElementById('game-start-countdown');
                const countdownNumberEl = countdownEl.querySelector('.countdown-number');
                const countdownTextEl = countdownEl.querySelector('.countdown-text');
                
                // Show "FIGHT!" message
                countdownTextEl.textContent = 'FIGHT!';
                countdownNumberEl.textContent = '';
                countdownEl.style.color = '#FF6B35'; // Orange color for "FIGHT!"
                
                // Hide countdown after 1 second and start game
                setTimeout(() => {
                    countdownEl.style.display = 'none';
                    
                    // Reset countdown display for next time
                    countdownTextEl.textContent = 'Game Starting...';
                    countdownEl.style.color = '#4CAF50';
                    
                    // Hide room UI and start the game
                    hideRoomUI();
                    gameStarted = true;
                    
                    // Reset the start button for next game
                    startGameBtn.disabled = false;
                    startGameBtn.textContent = 'Start Game';
                    
                    showMessage('Game started! Fight!', 'success');
                }, 1000);
                
                // Play game start sound effect (if available)
                // You could add audio here: new Audio('fight.mp3').play();
            });
            
            // ==================== END GAME START EVENT HANDLERS ====================
            
            // ==================== END ROOM EVENT HANDLERS ====================
        }

        function updatePlayerSprites() {
            // Remove sprites for disconnected players
            for (const id in playerSprites) {
                if (!gameState.players[id]) {
                    playerSprites[id].destroy();
                    playerHealthBars[id].background.destroy();
                    playerHealthBars[id].fill.destroy();
                    if (playerAttackEffects[id]) {
                        playerAttackEffects[id].destroy();
                    }
                    delete playerSprites[id];
                    delete playerHealthBars[id];
                    delete playerAttackEffects[id];
                }
            }
            
            // Update or create sprites for connected players
            for (const id in gameState.players) {
                const player = gameState.players[id];
                
                if (!playerSprites[id]) {
                    // Create new player sprite with physics body
                    const color = id === myPlayerId ? 0xff0000 : 0x0000ff;
                    playerSprites[id] = this.add.rectangle(player.x + 200, player.y, 40, 60, color); // Offset by 200px
                    
                    // Store player ID on sprite for reference
                    playerSprites[id].playerId = id;
                    
                    // Create health bar background
                    const healthBarBg = this.add.rectangle(player.x + 200, player.y - 40, 50, 8, 0x333333);
                    const healthBarFill = this.add.rectangle(player.x + 200, player.y - 40, 48, 6, 0x00ff00);
                    
                    playerHealthBars[id] = {
                        background: healthBarBg,
                        fill: healthBarFill
                    };
                    
                    // Create attack effect (initially invisible)
                    playerAttackEffects[id] = this.add.circle(player.x + 200, player.y, 35, 0xffff00, 0.6);
                    playerAttackEffects[id].setVisible(false);
                } else {
                    // Update existing sprite position (server handles physics)
                    // Skip position update for local player if prediction is enabled
                    if (!(predictionEnabled && id === myPlayerId)) {
                        playerSprites[id].setPosition(player.x + 200, player.y); // Add 200px offset
                    }
                    
                    // Update player color based on state
                    let playerColor = id === myPlayerId ? 0xff0000 : 0x0000ff;
                    let playerAlpha = 1.0;
                    
                    if (player.eliminated) {
                        playerColor = 0x333333; // Dark gray when eliminated
                        playerAlpha = 0.5;
                    } else if (player.isDead) {
                        playerColor = 0x666666; // Gray when dead
                        playerAlpha = 0.3;
                    } else if (player.isInvincible) {
                        playerColor = 0x00ffff; // Cyan when invincible
                        playerAlpha = 0.7 + Math.sin(Date.now() * 0.01) * 0.3; // Blinking effect
                    } else if (player.blocking) {
                        playerColor = 0xffff00; // Yellow when blocking
                    } else if (player.health <= 0) {
                        playerColor = 0x666666; // Gray when health is 0
                    }
                    
                    playerSprites[id].setFillStyle(playerColor);
                    playerSprites[id].setAlpha(playerAlpha);
                    
                    // Update health bar position and fill
                    // Use predicted position for local player, server position for others
                    const healthBarX = (predictionEnabled && id === myPlayerId && clientPlayerState) ? 
                        clientPlayerState.x + 200 : player.x + 200; // Add 200px offset
                    const healthBarY = (predictionEnabled && id === myPlayerId && clientPlayerState) ? 
                        clientPlayerState.y - 40 : player.y - 40;
                    
                    playerHealthBars[id].background.x = healthBarX;
                    playerHealthBars[id].background.y = healthBarY;
                    playerHealthBars[id].fill.x = healthBarX;
                    playerHealthBars[id].fill.y = healthBarY;
                    
                    // Update health bar width based on health
                    const healthPercent = player.health / 100;
                    playerHealthBars[id].fill.scaleX = healthPercent;
                    
                    // Update health bar color based on health
                    if (healthPercent > 0.6) {
                        playerHealthBars[id].fill.setFillStyle(0x00ff00);
                    } else if (healthPercent > 0.3) {
                        playerHealthBars[id].fill.setFillStyle(0xffff00);
                    } else {
                        playerHealthBars[id].fill.setFillStyle(0xff0000);
                    }
                    
                    // Update attack effect
                    if (player.attacking && playerAttackEffects[id]) {
                        playerAttackEffects[id].x = player.x + 200; // Add 200px offset
                        playerAttackEffects[id].y = player.y;
                        playerAttackEffects[id].setVisible(true);
                    } else if (playerAttackEffects[id]) {
                        playerAttackEffects[id].setVisible(false);
                    }
                }
            }
        }

        function updatePlayerCount() {
            const count = Object.keys(gameState.players).length;
            document.getElementById('player-count').textContent = `Players: ${count}`;
        }

        let lastUIUpdate = 0;
        let lastPlayerState = {};
        const UI_UPDATE_INTERVAL = 50; // Update UI only every 50ms
        
        function updateUI() {
            const now = Date.now();
            const myPlayer = gameState.players[myPlayerId];
            
            if (!myPlayer) return;
            
            // Check if player state has actually changed
            const currentState = {
                health: myPlayer.health,
                lives: myPlayer.lives,
                eliminated: myPlayer.eliminated,
                isDead: myPlayer.isDead,
                isInvincible: myPlayer.isInvincible
            };
            
            const stateChanged = JSON.stringify(currentState) !== JSON.stringify(lastPlayerState);
            
            // Throttle UI updates unless state changed
            if (!stateChanged && now - lastUIUpdate < UI_UPDATE_INTERVAL) {
                return;
            }
            
            lastUIUpdate = now;
            lastPlayerState = currentState;
            
            document.getElementById('health').textContent = `Health: ${myPlayer.health}`;
            document.getElementById('lives').textContent = `Lives: ${myPlayer.lives}`;
            
            // Update match status
            const statusElement = document.getElementById('match-status');
            if (myPlayer.eliminated) {
                statusElement.textContent = 'ELIMINATED - Spectating';
                statusElement.style.color = '#ff6666';
            } else if (myPlayer.isDead) {
                statusElement.textContent = 'RESPAWNING...';
                statusElement.style.color = '#ffff66';
            } else if (myPlayer.isInvincible) {
                statusElement.textContent = 'INVINCIBLE';
                statusElement.style.color = '#66ffff';
            } else {
                statusElement.textContent = '';
            }
        }

        function update() {
            const currentTime = Date.now();
            
            // Dash input detection system
            let dashDirection = null; // null, 'left', or 'right'
            
            // Update dash input cooldown
            if (dashInputCooldown > 0) {
                dashInputCooldown -= 16.67; // Approximate frame time (60fps)
            }
            
            // Check for dedicated dash key (Shift) + direction
            if (Phaser.Input.Keyboard.JustDown(shiftKey) && dashInputCooldown <= 0) {
                if (cursors.left.isDown) {
                    dashDirection = 'left';
                    dashInputCooldown = DASH_INPUT_COOLDOWN;
                } else if (cursors.right.isDown) {
                    dashDirection = 'right';
                    dashInputCooldown = DASH_INPUT_COOLDOWN;
                }
            }
            
            // Check for double-tap dash (left/right keys)
            if (dashInputCooldown <= 0) {
                // Left key double-tap detection
                if (Phaser.Input.Keyboard.JustDown(cursors.left)) {
                    if (currentTime - lastLeftKeyTime <= DASH_DOUBLE_TAP_WINDOW) {
                        dashDirection = 'left';
                        dashInputCooldown = DASH_INPUT_COOLDOWN;
                    }
                    lastLeftKeyTime = currentTime;
                }
                
                // Right key double-tap detection  
                if (Phaser.Input.Keyboard.JustDown(cursors.right)) {
                    if (currentTime - lastRightKeyTime <= DASH_DOUBLE_TAP_WINDOW) {
                        dashDirection = 'right';
                        dashInputCooldown = DASH_INPUT_COOLDOWN;
                    }
                    lastRightKeyTime = currentTime;
                }
            }
            
            const inputs = {
                left: cursors.left.isDown,
                right: cursors.right.isDown,
                jump: Phaser.Input.Keyboard.JustDown(cursors.up),
                attack: Phaser.Input.Keyboard.JustDown(spaceKey),
                block: zKey.isDown,
                down: cursors.down.isDown,
                dash: dashDirection // Add dash direction to inputs
            };
            
            // Client-side prediction for smooth gameplay
            if (predictionEnabled && myPlayerId && gameState.players[myPlayerId]) {
                // Initialize client state if needed
                if (!clientPlayerState) {
                    initializeClientPlayerState();
                }
                
                // Apply inputs immediately on client for responsiveness
                applyClientSidePrediction(inputs);
                
                // Buffer input for server reconciliation
                bufferInput(inputs);
            }
            
            socket.emit('input', inputs);
        }
        
        // Client-side prediction functions
        function initializeClientPlayerState() {
            const serverPlayer = gameState.players[myPlayerId];
            if (!serverPlayer) return;
            
            // Perfect sync with server state
            clientPlayerState = {
                x: serverPlayer.x,
                y: serverPlayer.y,
                velocityX: serverPlayer.velocityX || 0,
                velocityY: serverPlayer.velocityY || 0,
                isGrounded: serverPlayer.isGrounded !== undefined ? serverPlayer.isGrounded : true,
                jumpsRemaining: serverPlayer.jumpsRemaining || 2,
                lastJumpTime: serverPlayer.lastJumpTime || 0,
                blocking: serverPlayer.blocking || false,
                health: serverPlayer.health,
                droppingTimer: 0, // frames left to ignore one-way collisions
                isDashing: false, // New for dash state
                dashDirection: 0, // New for dash direction
                dashStartTime: 0, // New for dash start time
                lastDashTime: 0, // New for last dash time
                dashVelocity: 0 // New for dash velocity
            };
            
            // Force immediate position sync to eliminate initial error
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                updateLocalPlayerHealthBar();
            }
        }
        
        function updateLocalPlayerHealthBar() {
            if (predictionEnabled && myPlayerId && clientPlayerState && playerHealthBars[myPlayerId]) {
                const healthBarX = clientPlayerState.x + 200; // Add 200px offset
                const healthBarY = clientPlayerState.y - 40;
                
                playerHealthBars[myPlayerId].background.x = healthBarX;
                playerHealthBars[myPlayerId].background.y = healthBarY;
                playerHealthBars[myPlayerId].fill.x = healthBarX;
                playerHealthBars[myPlayerId].fill.y = healthBarY;
            }
        }

        // Utility: returns true if we should ignore one-way platforms this frame
        function isDroppingThrough() {
            return clientPlayerState && clientPlayerState.droppingTimer && clientPlayerState.droppingTimer > 0;
        }

        function getClientGroundState(player, ignoreOneWay) {
            const { PLATFORMS, PLATFORM_TYPES, PLATFORM_PHYSICS, PlatformUtils } = window.PlatformConfig;

            let isGrounded = false;
            let groundY = PHYSICS_CONSTANTS.GROUND_Y; // default ground level
            let landedPlatform = null;

            const halfPlayerHeight = PLATFORM_PHYSICS.PLAYER_HEIGHT / 2;

            for (const platform of PLATFORMS) {
                const playerBounds = PlatformUtils.getPlayerBounds(player);
                const platformBounds = PlatformUtils.getPlatformBounds(platform);

                // Horizontal overlap check
                const horizontallyOverlapping = playerBounds.left < platformBounds.right &&
                                                playerBounds.right > platformBounds.left;
                if (!horizontallyOverlapping) continue;

                const platformTop = platform.y - platform.height / 2;
                const playerBottom = player.y + halfPlayerHeight;
                const distToTop = playerBottom - platformTop;

                // Within landing tolerance and falling/downwards movement
                const nearPlatform = distToTop >= -20 && distToTop <= 20;

                if (nearPlatform && player.velocityY >= 0) {
                    if (platform.type === PLATFORM_TYPES.ONE_WAY) {
                        // Ignore collision while dropping through
                        if (ignoreOneWay || isDroppingThrough()) {
                            continue;
                        }
                        // Can only land if coming from above the platform
                        if (player.y < platformTop) {
                            isGrounded = true;
                            groundY = PlatformUtils.getPlayerStandingY(platform);
                            landedPlatform = platform;
                            break;
                        }
                    } else {
                        // SOLID / SPAWN platforms – collide from any direction (primarily above)
                        isGrounded = true;
                        groundY = PlatformUtils.getPlayerStandingY(platform);
                        landedPlatform = platform;
                        break;
                    }
                }
            }

            // No hardcoded ground fallback - match server behavior
            // Players should only collide with defined platforms for fall-off deaths to work

            return { isGrounded, groundY, platform: landedPlatform };
        }
 
        function applyClientSidePrediction(inputs) {
            const deltaTime = 1 / PHYSICS_CONSTANTS.FRAME_RATE;
            const now = Date.now();
            
            // Apply same anti-cheat logic as server: prevent conflicting inputs
            let inputsCancelled = false;
            if (inputs.left && inputs.right) {
                inputs.left = false;
                inputs.right = false;
                inputsCancelled = true;
            }
            
            // Update debug panel input status
            const inputStatusElement = document.getElementById('input-status');
            if (inputStatusElement) {
                if (inputsCancelled) {
                    inputStatusElement.textContent = 'CANCELLED (L+R)';
                    inputStatusElement.style.color = '#ff6666';
                } else {
                    inputStatusElement.textContent = 'Normal';
                    inputStatusElement.style.color = '#66ff66';
                }
            }
            
            // Movement prediction with improved accuracy
            const moveSpeed = clientPlayerState.blocking ? 3 : 6; // Match server MOVEMENT_SPEED (1.5x faster)
            
            // Better direction change handling - reset velocity first
            let newVelocityX = 0;
            
            if (inputs.left) {
                newVelocityX = -moveSpeed;
                clientPlayerState.x -= moveSpeed;
            } else if (inputs.right) {
                newVelocityX = moveSpeed;
                clientPlayerState.x += moveSpeed;
            }
            
            // Immediately update velocity to match server behavior
            clientPlayerState.velocityX = newVelocityX;
            
            // Jump prediction with exact server matching
            if (inputs.jump && validateClientJump(now)) {
                performClientJump(now);
            }
            
            // Dash prediction with client-side validation
            if (inputs.dash && validateClientDash(now)) {
                performClientDash(inputs.dash, now);
            }
            
            // ---------------------------------------------------------------------------
            // Vertical movement & collision (platform-aware)
            // ---------------------------------------------------------------------------

            const ignoreOneWayNow = inputs.down || isDroppingThrough(); // hold or active drop
            // Evaluate current ground state BEFORE movement
            let groundState = getClientGroundState(clientPlayerState, ignoreOneWayNow);

            // Allow drop-through ONLY when on a ONE_WAY platform
            const wantsToDrop = inputs.down && groundState.isGrounded &&
                                groundState.platform && groundState.platform.type === window.PlatformConfig.PLATFORM_TYPES.ONE_WAY;

            if (wantsToDrop) {
                // Initiate a small downward velocity so gravity takes over
                clientPlayerState.velocityY = Math.max(clientPlayerState.velocityY, 200); // faster pass-through
                clientPlayerState.droppingTimer = 12; // ignore one-way collisions for ~200ms (12 frames)
                groundState.isGrounded = false;
                clientPlayerState.isGrounded = false;
            }

            // Decrement droppingTimer each frame
            if (clientPlayerState.droppingTimer && clientPlayerState.droppingTimer > 0) {
                clientPlayerState.droppingTimer--;
            }

            // Apply gravity when not grounded
            if (!groundState.isGrounded) {
                clientPlayerState.velocityY += PHYSICS_CONSTANTS.GRAVITY * deltaTime;
                // Proposed next position
                const candidateY = clientPlayerState.y + clientPlayerState.velocityY * deltaTime;
                // If we would overshoot a SOLID/SPAWN platform or ground, clamp smoothly
                if (groundState.isGrounded && candidateY > groundState.groundY &&
                    (!groundState.platform || groundState.platform.type !== window.PlatformConfig.PLATFORM_TYPES.ONE_WAY || !ignoreOneWayNow)) {
                    clientPlayerState.y = groundState.groundY;
                } else {
                    clientPlayerState.y = candidateY;
                }
            }

            // Re-evaluate ground state AFTER movement to clamp to platforms/ground
            groundState = getClientGroundState(clientPlayerState, ignoreOneWayNow);

            // Smoothly settle onto platform/ground to remove visible gaps without hard snap
            if (groundState.isGrounded) {
                const diff = groundState.groundY - clientPlayerState.y; // positive if below surface, negative if floating above
                const absDiff = Math.abs(diff);
                if (absDiff > 0.5) { // ignore sub-pixel noise
                    const settleFactor = absDiff > 8 ? 1 : 0.5; // big error – snap, small – glide
                    clientPlayerState.y += diff * settleFactor;
                }
            }

            const serverPlayer = gameState.players[myPlayerId];
            const serverAgreesGrounded = serverPlayer && serverPlayer.isGrounded;

            // Improved ground state synchronization
            if (groundState.isGrounded) {
                if (serverAgreesGrounded) {
                    // Both client and server agree - maintain stable state
                    clientPlayerState.velocityY = 0;
                    if (!clientPlayerState.isGrounded) {
                        clientPlayerState.isGrounded = true;
                        clientPlayerState.jumpsRemaining = 2;
                    }
                } else if (Math.abs(clientPlayerState.y - (serverPlayer?.y || 0)) < 10) {
                    // Small position difference - trust client prediction
                    clientPlayerState.velocityY = 0;
                    clientPlayerState.isGrounded = true;
                }
            } else {
                // Not grounded on any platform
                clientPlayerState.isGrounded = false;
            }
            
            // Update blocking state
            clientPlayerState.blocking = inputs.block;
            
            // Allow free movement beyond boundaries for fall-off deaths
            // No horizontal clamping - players can now fall off the sides
            
            // Apply predicted position to sprite
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y); // Add 200px offset
                updateLocalPlayerHealthBar();
            }
        }
        
        function validateClientJump(currentTime) {
            if (!clientPlayerState || clientPlayerState.health <= 0) return false;
            if (clientPlayerState.jumpsRemaining <= 0) return false;
            if (currentTime - clientPlayerState.lastJumpTime < 200) return false;
            return true;
        }
        
        function performClientJump(currentTime) {
            const jumpVelocity = clientPlayerState.jumpsRemaining === 2 ? 
                PHYSICS_CONSTANTS.JUMP_VELOCITY_SINGLE : 
                PHYSICS_CONSTANTS.JUMP_VELOCITY_DOUBLE;
            
            clientPlayerState.velocityY = jumpVelocity;
            clientPlayerState.jumpsRemaining--;
            clientPlayerState.isGrounded = false;
            clientPlayerState.lastJumpTime = currentTime;
        }
        
        function validateClientDash(currentTime) {
            if (!clientPlayerState || clientPlayerState.health <= 0) return false;
            if (dashInputCooldown > 0) return false; // Prevent multiple dash triggers
            if (clientPlayerState.isDashing) return false; // Prevent dash while already dashing
            if (currentTime - (clientPlayerState.lastDashTime || 0) < 350) return false; // Dash cooldown (reduced from 500)
            return true;
        }

        function performClientDash(direction, currentTime) {
            const dashVelocity = 900; // Match server DASH_VELOCITY (increased from 300)
            const dashDirection = direction === 'left' ? -1 : 1;
            
            // Apply dash physics immediately
            clientPlayerState.isDashing = true;
            clientPlayerState.dashDirection = dashDirection;
            clientPlayerState.dashStartTime = currentTime;
            clientPlayerState.lastDashTime = currentTime;
            clientPlayerState.dashVelocity = dashVelocity * dashDirection;
            
            // Apply immediate velocity boost for responsive feel
            clientPlayerState.velocityX += clientPlayerState.dashVelocity;
            
            // Apply movement immediately  
            const deltaTime = 1 / PHYSICS_CONSTANTS.FRAME_RATE;
            clientPlayerState.x += clientPlayerState.dashVelocity * deltaTime;
            
            // Update sprite position immediately
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                updateLocalPlayerHealthBar();
            }
            
            console.log(`Client predicted dash ${direction} with velocity ${clientPlayerState.dashVelocity}`);
        }
        
        function bufferInput(inputs) {
            // Store input with timestamp for server reconciliation
            inputBuffer.push({
                inputs: { ...inputs },
                timestamp: Date.now(),
                clientState: { ...clientPlayerState }
            });
            
            // Keep buffer size manageable (last 1 second of inputs)
            const oneSecondAgo = Date.now() - 1000;
            inputBuffer = inputBuffer.filter(entry => entry.timestamp > oneSecondAgo);
        }
        
        function reconcileWithServer(serverState) {
            if (!clientPlayerState || !predictionEnabled) return;
            
            const serverPlayer = serverState.players[myPlayerId];
            if (!serverPlayer) return;
            
            // Calculate position difference
            const positionError = Math.sqrt(
                Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                Math.pow(clientPlayerState.y - serverPlayer.y, 2)
            );
            
            // Calculate velocity difference for better correction
            const serverVelX = serverPlayer.velocityX || 0;
            const serverVelY = serverPlayer.velocityY || 0;
            const velocityError = Math.sqrt(
                Math.pow(clientPlayerState.velocityX - serverVelX, 2) + 
                Math.pow(clientPlayerState.velocityY - serverVelY, 2)
            );
            
            // Smart error thresholds based on movement state
            let errorThreshold = 8; // More lenient base threshold for smooth movement
            let velocityThreshold = 75;
            
            // Even more lenient thresholds when actively moving to prevent fighting
            if (Math.abs(serverVelX) > 1) {
                errorThreshold = 12; // Very lenient when moving horizontally
                velocityThreshold = 150;
            } else if (serverPlayer.isGrounded && Math.abs(serverVelX) < 1 && Math.abs(serverVelY) < 1) {
                errorThreshold = 6; // Tighter when stationary
                velocityThreshold = 100;
            }
            
            // Gentler correction factors for smoother movement
            let correctionFactor = 0.05; // Much gentler base correction
            if (positionError > 25) {
                correctionFactor = 0.3; // Still aggressive for large errors
            } else if (positionError > 15) {
                correctionFactor = 0.15; // Moderate correction
            } else if (velocityError > velocityThreshold) {
                correctionFactor = 0.1; // Gentle velocity-based correction
            }
            
            // Apply correction if error is significant
            if (positionError > errorThreshold || velocityError > velocityThreshold) {
                // Smooth interpolation towards server position
                clientPlayerState.x += (serverPlayer.x - clientPlayerState.x) * correctionFactor;
                clientPlayerState.y += (serverPlayer.y - clientPlayerState.y) * correctionFactor;
                
                // Always sync velocities to prevent drift
                clientPlayerState.velocityX = serverVelX;
                clientPlayerState.velocityY = serverVelY;
                
                // Sync critical physics state
                clientPlayerState.isGrounded = serverPlayer.isGrounded;
                clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
                
                // Apply corrected position to sprite
                if (playerSprites[myPlayerId]) {
                    playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                    updateLocalPlayerHealthBar();
                }
            }
            
            // Update non-predicted states
            clientPlayerState.health = serverPlayer.health;
            lastServerUpdate = Date.now();
            
            // Update debug panel
            updateDebugPanel();
        }
        
        let lastDebugUpdate = 0;
        const DEBUG_UPDATE_INTERVAL = 100; // Update debug panel only every 100ms
        
        function updateDebugPanel() {
            const now = Date.now();
            
            // Always update prediction status immediately when toggled, throttle other updates
            const statusElement = document.getElementById('prediction-status');
            if (statusElement) {
                statusElement.textContent = predictionEnabled ? 'ON' : 'OFF';
                statusElement.style.color = predictionEnabled ? '#66ff66' : '#ff6666';
            }
            
            // Throttle other debug panel updates to reduce DOM manipulation
            if (now - lastDebugUpdate < DEBUG_UPDATE_INTERVAL) {
                return;
            }
            lastDebugUpdate = now;
            
            document.getElementById('buffer-size').textContent = inputBuffer.length;
            document.getElementById('last-update').textContent = now - lastServerUpdate;
            
            if (predictionEnabled && clientPlayerState && gameState.players[myPlayerId]) {
                const serverPlayer = gameState.players[myPlayerId];
                const positionError = Math.sqrt(
                    Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                    Math.pow(clientPlayerState.y - serverPlayer.y, 2)
                );
                
                // Calculate velocity error for debug display
                const serverVelX = serverPlayer.velocityX || 0;
                const serverVelY = serverPlayer.velocityY || 0;
                const velocityError = Math.sqrt(
                    Math.pow(clientPlayerState.velocityX - serverVelX, 2) + 
                    Math.pow(clientPlayerState.velocityY - serverVelY, 2)
                );
                
                document.getElementById('position-error').textContent = positionError.toFixed(1);
                
                // Add velocity error to debug if position error is high
                if (positionError > 10 || velocityError > 20) {
                    document.getElementById('position-error').textContent += ` (vel: ${velocityError.toFixed(1)})`;
                }
            } else {
                document.getElementById('position-error').textContent = '0.0';
            }
        }
        
        function handleJumpEvent(jumpEvent) {
            // Handle jump event for visual effects (particle effects, sound, etc.)
            const playerSprite = playerSprites[jumpEvent.playerId];
            if (!playerSprite) return;
            
            // Visual feedback for jumps
            const jumpEffect = this.add.circle(jumpEvent.position.x + 200, jumpEvent.position.y + 30, 15, 0xFFFF00, 0.7);
            jumpEffect.setDepth(1000); // Render on top
            
            // Animate the effect
            this.tweens.add({
                targets: jumpEffect,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 300,
                ease: 'Power2',
                onComplete: () => {
                    jumpEffect.destroy();
                }
            });
            
            // Different effects for single vs double jump
            if (jumpEvent.jumpType === 'double') {
                // Add sparkle effect for double jump
                const sparkle = this.add.circle(jumpEvent.position.x + 200, jumpEvent.position.y + 25, 8, 0xFF00FF, 0.9);
                sparkle.setDepth(1001);
                
                this.tweens.add({
                    targets: sparkle,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    alpha: 0,
                    duration: 200,
                    ease: 'Power1',
                    onComplete: () => sparkle.destroy()
                });
            }
        }
        
        function handleDashEvent(dashEvent) {
            // Handle dash event for visual effects (particle trail, sound, etc.)
            const playerSprite = playerSprites[dashEvent.playerId];
            if (!playerSprite) return;
            
            // Visual feedback for dash - create trail effect
            const dashTrail = this.add.rectangle(
                dashEvent.position.x + 200, 
                dashEvent.position.y, 
                60, 
                20, 
                0x00FFFF, 
                0.6
            );
            dashTrail.setDepth(999); // Render behind player but above background
            
            // Animate the trail effect
            this.tweens.add({
                targets: dashTrail,
                scaleX: dashEvent.direction === 'left' ? -0.2 : 0.2,
                scaleY: 0.5,
                alpha: 0,
                duration: 200,
                ease: 'Power2',
                onComplete: () => {
                    dashTrail.destroy();
                }
            });
            
            // Add directional speed lines
            for (let i = 0; i < 3; i++) {
                const speedLine = this.add.rectangle(
                    dashEvent.position.x + 200 + (dashEvent.direction === 'left' ? 20 : -20) * (i + 1), // Add 200px offset
                    dashEvent.position.y + (Math.random() - 0.5) * 30,
                    15,
                    3,
                    0xFFFFFF,
                    0.8
                );
                speedLine.setDepth(998);
                
                this.tweens.add({
                    targets: speedLine,
                    x: speedLine.x + (dashEvent.direction === 'left' ? -30 : 30),
                    alpha: 0,
                    duration: 150 + i * 50,
                    ease: 'Linear',
                    onComplete: () => speedLine.destroy()
                });
            }
            
            console.log(`Dash visual effect for player ${dashEvent.playerId} direction ${dashEvent.direction}`);
        }
        
        function handleDashInterruption(interruptEvent) {
            // Handle dash interruption for visual effects cleanup
            const playerSprite = playerSprites[interruptEvent.playerId];
            if (!playerSprite) return;
            
            // Clean up any active dash visual effects
            this.children.getChildren().forEach(child => {
                if (child.name && (child.name.includes('dashTrail') || child.name.includes('speedLine'))) {
                    child.destroy();
                }
            });
            
            // Visual feedback for dash interruption (brief flash effect)
            if (playerSprite) {
                this.tweens.add({
                    targets: playerSprite,
                    alpha: 0.5,
                    duration: 100,
                    yoyo: true,
                    ease: 'Power2'
                });
            }
            
            console.log(`Dash interrupted for player ${interruptEvent.playerId}: ${interruptEvent.reason}`);
        }
        
        function handlePlayerDeath(deathEvent) {
            console.log(`Player ${deathEvent.playerId} died! Lives remaining: ${deathEvent.livesRemaining}`);
            
            // Create death effect at death position
            const deathEffect = this.add.circle(deathEvent.deathPosition.x + 200, deathEvent.deathPosition.y, 50, 0xff0000, 0.8);
            deathEffect.setDepth(1000);
            
            // Animate death effect
            this.tweens.add({
                targets: deathEffect,
                scaleX: 3,
                scaleY: 3,
                alpha: 0,
                duration: 500,
                ease: 'Power2',
                onComplete: () => deathEffect.destroy()
            });
            
            // Handle local player death with countdown and fade effects
            if (deathEvent.playerId === myPlayerId && !deathEvent.isEliminated) {
                // Screen shake for local player death
                this.cameras.main.shake(300, 0.02);
                
                // Start fade effect on player sprite
                if (playerSprites[myPlayerId]) {
                    this.tweens.add({
                        targets: playerSprites[myPlayerId],
                        alpha: 0.2,
                        duration: 3000, // Fade over 3 seconds
                        ease: 'Linear'
                    });
                }
                
                // Start respawn countdown
                startRespawnCountdown();
            }
            
            // For other players, just fade their sprite
            if (deathEvent.playerId !== myPlayerId && playerSprites[deathEvent.playerId]) {
                this.tweens.add({
                    targets: playerSprites[deathEvent.playerId],
                    alpha: 0.3,
                    duration: 1000,
                    ease: 'Power2'
                });
            }
        }
        
        function startRespawnCountdown() {
            const countdownElement = document.getElementById('respawn-countdown');
            let timeLeft = 3;
            
            function updateCountdown() {
                if (timeLeft > 0) {
                    countdownElement.textContent = timeLeft;
                    countdownElement.style.display = 'block';
                    
                    // Pulse effect for countdown
                    countdownElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        countdownElement.style.transform = 'translate(-50%, -50%) scale(1.0)';
                    }, 200);
                    
                    timeLeft--;
                    setTimeout(updateCountdown, 1000);
                } else {
                    countdownElement.style.display = 'none';
                }
            }
            
            updateCountdown();
        }
        
        function handlePlayerRespawn(respawnEvent) {
            console.log(`Player ${respawnEvent.playerId} respawned with invincibility`);
            
            // Restore sprite alpha for respawned player
            if (playerSprites[respawnEvent.playerId]) {
                // Stop any existing fade tweens
                this.tweens.killTweensOf(playerSprites[respawnEvent.playerId]);
                // Restore full alpha
                playerSprites[respawnEvent.playerId].setAlpha(1.0);
            }
            
            // Create respawn effect
            const respawnEffect = this.add.circle(respawnEvent.position.x + 200, respawnEvent.position.y, 30, 0x00ffff, 0.7);
            respawnEffect.setDepth(1000);
            
            // Animate respawn effect
            this.tweens.add({
                targets: respawnEffect,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => respawnEffect.destroy()
            });
            
            // Add sparkle effects
            for (let i = 0; i < 8; i++) {
                const sparkle = this.add.circle(
                    respawnEvent.position.x + 200 + (Math.random() - 0.5) * 60, // Add 200px offset
                    respawnEvent.position.y + (Math.random() - 0.5) * 60,
                    3,
                    0xffffff,
                    0.9
                );
                sparkle.setDepth(1001);
                
                this.tweens.add({
                    targets: sparkle,
                    scaleX: 2,
                    scaleY: 2,
                    alpha: 0,
                    duration: 300 + Math.random() * 200,
                    ease: 'Power1',
                    onComplete: () => sparkle.destroy()
                });
            }
            
            // Hide countdown for local player
            if (respawnEvent.playerId === myPlayerId) {
                const countdownElement = document.getElementById('respawn-countdown');
                countdownElement.style.display = 'none';
            }
        }
        
        function handlePlayerElimination(eliminationEvent) {
            console.log(`Player ${eliminationEvent.playerId} eliminated!`);
            
            // Create elimination effect
            const eliminationEffect = this.add.circle(eliminationEvent.finalPosition.x + 200, eliminationEvent.finalPosition.y, 80, 0xff6600, 0.9);
            eliminationEffect.setDepth(1000);
            
            // Animate elimination effect
            this.tweens.add({
                targets: eliminationEffect,
                scaleX: 4,
                scaleY: 4,
                alpha: 0,
                duration: 800,
                ease: 'Power3',
                onComplete: () => eliminationEffect.destroy()
            });
            
            // Add text effect
            const eliminationText = this.add.text(eliminationEvent.finalPosition.x + 200, eliminationEvent.finalPosition.y - 50, 'ELIMINATED!', {
                fontSize: '24px',
                fill: '#ff6600',
                stroke: '#000000',
                strokeThickness: 2
            });
            eliminationText.setOrigin(0.5);
            eliminationText.setDepth(1001);
            
            this.tweens.add({
                targets: eliminationText,
                y: eliminationText.y - 100,
                alpha: 0,
                duration: 1000,
                ease: 'Power2',
                onComplete: () => eliminationText.destroy()
            });
        }
        
        function handleMatchEnd(matchEndEvent) {
            console.log(`Match ended! Winner: ${matchEndEvent.winnerId}`);
            
            // Create match end overlay
            const overlay = this.add.rectangle(600, 500, 1200, 1000, 0x000000, 0.7); // Expanded to 1200x1000, centered at (600, 500)
            overlay.setDepth(2000);
            
            // Winner text
            const winnerText = matchEndEvent.winnerId === myPlayerId ? 'YOU WIN!' : 
                              matchEndEvent.winnerId ? 'MATCH OVER' : 'DRAW!';
            const winnerColor = matchEndEvent.winnerId === myPlayerId ? '#00ff00' : '#ffffff';
            
            const matchEndText = this.add.text(600, 400, winnerText, { // Centered at 600 for 1200px canvas
                fontSize: '48px',
                fill: winnerColor,
                stroke: '#000000',
                strokeThickness: 3
            });
            matchEndText.setOrigin(0.5);
            matchEndText.setDepth(2001);
            
            // Final standings text
            let standingsText = 'Final Standings:\n';
            matchEndEvent.finalStandings.forEach((standing, index) => {
                const position = index + 1;
                const playerText = standing.playerId === myPlayerId ? 'YOU' : `Player ${standing.playerId.slice(-4)}`;
                standingsText += `${position}. ${playerText} - ${standing.lives} lives\n`;
            });
            
            const standingsDisplay = this.add.text(600, 550, standingsText, { // Centered at 600 for 1200px canvas
                fontSize: '18px',
                fill: '#ffffff',
                align: 'center'
            });
            standingsDisplay.setOrigin(0.5);
            standingsDisplay.setDepth(2001);
            
            // Store overlay elements for cleanup
            this.matchEndOverlay = [overlay, matchEndText, standingsDisplay];
        }
        
        function handleMatchReset(resetEvent) {
            console.log('Match reset - new round starting!');
            
            // Clean up match end overlay
            if (this.matchEndOverlay) {
                this.matchEndOverlay.forEach(element => element.destroy());
                this.matchEndOverlay = null;
            }
            
            // Create new round announcement
            const newRoundText = this.add.text(600, 500, 'NEW ROUND!', { // Centered at 600 for 1200px canvas
                fontSize: '36px',
                fill: '#ffff00',
                stroke: '#000000',
                strokeThickness: 2
            });
            newRoundText.setOrigin(0.5);
            newRoundText.setDepth(1000);
            
            // Animate and remove announcement
            this.tweens.add({
                targets: newRoundText,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 2000,
                ease: 'Power2',
                onComplete: () => newRoundText.destroy()
            });
        }
        
        function handleInvincibilityEnd(invincibilityEvent) {
            console.log(`Player ${invincibilityEvent.playerId} invincibility ended`);
            
            // Visual feedback for invincibility ending (small flash effect)
            if (playerSprites[invincibilityEvent.playerId]) {
                const player = playerSprites[invincibilityEvent.playerId];
                this.tweens.add({
                    targets: player,
                    alpha: 0.3,
                    duration: 100,
                    yoyo: true,
                    repeat: 2,
                    ease: 'Power1'
                });
            }
        }
    </script>
</body>
</html> 