<!DOCTYPE html>
<html>
<head>
    <title>Super Vibe Bros</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="platforms.js"></script>
    
    <!-- Firebase CDN -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            /* Removed border and border-radius for cleaner look */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            z-index: 1000;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 1000;
        }
        #respawn-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ff6666;
            padding: 30px;
            border-radius: 15px;
            font-size: 64px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 2000;
            border: 3px solid #ff6666;
            box-shadow: 0 0 30px rgba(255, 102, 102, 0.5);
        }
        
        /* Game Start Countdown */
        #game-start-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #4CAF50;
            padding: 40px;
            border-radius: 20px;
            font-size: 72px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 3000;
            border: 4px solid #4CAF50;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.6);
            animation: pulse 0.5s ease-in-out infinite alternate;
        }
        
        #game-start-countdown .countdown-text {
            font-size: 28px;
            margin-bottom: 10px;
            color: #81C784;
        }
        
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* Game Over Screen */
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            display: none;
            z-index: 3500;
            border: 3px solid #4CAF50;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.4);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #game-over-screen h1 {
            text-align: center;
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 36px;
        }
        
        #game-over-screen .winner-text {
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            color: #FFD700;
        }
        
        #game-over-screen .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #game-over-screen .stats-table th,
        #game-over-screen .stats-table td {
            padding: 12px 15px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #game-over-screen .stats-table th {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
            font-weight: bold;
        }
        
        #game-over-screen .stats-table tr.winner {
            background: rgba(255, 215, 0, 0.2);
            border-left: 4px solid #FFD700;
        }
        
        #game-over-screen .stats-table tr.current-player {
            background: rgba(76, 175, 80, 0.2);
            border-left: 4px solid #4CAF50;
        }
        
        #game-over-screen .stats-table tr.disconnected {
            background: rgba(128, 128, 128, 0.2);
            border-left: 4px solid #888;
            color: #aaa;
            font-style: italic;
        }
        
        #game-over-screen .game-over-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        #game-over-screen .game-over-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        #game-over-screen .rematch-btn {
            background: #4CAF50;
            color: white;
        }
        
        #game-over-screen .rematch-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        #game-over-screen .lobby-btn {
            background: #2196F3;
            color: white;
        }
        
        #game-over-screen .lobby-btn:hover {
            background: #1976D2;
            transform: translateY(-2px);
        }
        
        #game-over-screen .rematch-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Room Management UI Styles */
        #room-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 1500;
            border: 2px solid #4CAF50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.3);
            font-family: Arial, sans-serif;
            min-width: 400px;
        }
        
        #room-ui h1 {
            margin: 0 0 30px 0;
            color: #4CAF50;
            font-size: 36px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        #room-ui h2 {
            margin: 20px 0 15px 0;
            color: #ffffff;
            font-size: 24px;
        }
        
        .room-section {
            margin: 16px 0;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            text-align: center;
        }
        
        .room-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: auto;
            margin-bottom: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            display: inline-block;
        }
        
        .room-button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .room-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .room-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4CAF50;
            color: white;
            padding: 12px 20px;
            font-size: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 10px;
            width: 120px;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        
        .room-input:focus {
            outline: none;
            border-color: #66BB6A;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        #room-code-display {
            font-size: 36px;
            font-weight: bold;
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            padding: 20px;
            border-radius: 15px;
            letter-spacing: 8px;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.7);
            border: 2px solid #4CAF50;
            margin: 20px 0;
        }
        
        #player-list {
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .player-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .player-host {
            background: rgba(76, 175, 80, 0.2);
            border-left: 4px solid #4CAF50;
        }
        
        .error-message {
            color: #f44336;
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid #f44336;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .warning-message {
            color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid #ff9800;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from { box-shadow: 0 0 5px rgba(255, 152, 0, 0.5); }
            to { box-shadow: 0 0 20px rgba(255, 152, 0, 0.8); }
        }
        
        .success-message {
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        #room-ui.hidden {
            display: none;
        }

        /* Disconnection Countdown Toast */
        .disconnect-toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #FF5722;
            color: #000;
            padding: 30px 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 4000;
            border: 3px solid #000;
            box-shadow: 0 0 40px rgba(255, 87, 34, 0.6);
            display: none;
            width: 500px;
        }

        .disconnect-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .disconnect-message {
            font-size: 16px;
            margin-bottom: 15px;
        }

        .disconnect-timer {
            font-size: 64px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .disconnect-subtext {
            font-size: 14px;
        }

    </style>
</head>
<body>
    <div id="ui">
        <div id="player-count">Players: 0</div>
        <div id="health">Health: 100</div>
        <div id="lives">Lives: 3</div>
        <div id="match-status"></div>
    </div>
    
    <!-- Room Management UI -->
    <div id="room-ui">
        <img src="assets/supervibebros-pixel.png" alt="Super Vibe Bros" style="height: 160px; vertical-align: middle;">
        
        <!-- Authentication Section -->
        <div id="auth-section">
            <div class="room-section">
                <h3>How would you like to play?</h3>
                
                <!-- Guest Play Option -->
                <div class="auth-option">
                    <h3 style="color: #4CAF50; margin: 10px 0;">🎮 Play as Guest</h3>
                    <p style="color: #aaa; font-size: 14px; margin: 10px 0;">Jump right in! No account needed.</p>
                    <input type="text" id="guest-name-input" class="room-input" placeholder="Your Name" maxlength="20" style="width: 200px; margin: 10px;" />
                    <br>
                    <button id="guest-play-btn" class="room-button">Start Playing</button>
                </div>
                
                <div style="margin: 20px 0; color: #666;">- OR -</div>
                
                <!-- Registered User Options -->
                <div class="auth-option">
                    <h3 style="color: #2196F3; margin: 10px 0;">👤 Account Login</h3>
                    <p style="color: #aaa; font-size: 14px; margin: 10px 0;">Save your progress and stats!</p>
                    <button id="show-login-btn" class="room-button" style="background: #2196F3;">Login</button>
                    <button id="show-register-btn" class="room-button" style="background: #FF9800; margin-left: 10px;">Register</button>
                </div>
            </div>
        </div>
        
        <!-- Login Form -->
        <div id="login-form" style="display: none;">
            <div class="room-section">
                <h2>Login to Your Account</h2>
                <input type="email" id="login-email" class="room-input" placeholder="Email" style="width: 250px; margin: 5px;" />
                <br>
                <input type="password" id="login-password" class="room-input" placeholder="Password" style="width: 250px; margin: 5px;" />
                <br>
                <button id="login-submit-btn" class="room-button" style="background: #2196F3;">Login</button>
                <button id="back-to-auth-btn" class="room-button" style="background: #666; margin-left: 10px;">Back</button>
            </div>
        </div>
        
        <!-- Register Form -->
        <div id="register-form" style="display: none;">
            <div class="room-section">
                <h2>Create New Account</h2>
                <input type="text" id="register-username" class="room-input" placeholder="Username" style="width: 250px; margin: 5px;" />
                <br>
                <input type="email" id="register-email" class="room-input" placeholder="Email" style="width: 250px; margin: 5px;" />
                <br>
                <input type="password" id="register-password" class="room-input" placeholder="Password" style="width: 250px; margin: 5px;" />
                <br>
                <button id="register-submit-btn" class="room-button" style="background: #FF9800;">Create Account</button>
                <button id="back-to-auth-btn2" class="room-button" style="background: #666; margin-left: 10px;">Back</button>
            </div>
        </div>
        
        <!-- Main Menu (when authenticated and not in room) -->
        <div id="main-menu" style="display: none;">
            <div id="authenticated-user-info" style="color: #4CAF50; margin-bottom: 20px; font-size: 14px;">
                <!-- User info will be populated here -->
            </div>
            
            <div class="room-section">
                <h2>Create a New Game</h2>
                <button id="create-room-btn" class="room-button">Create Room</button>
                <p style="color: #aaa; font-size: 14px;">Share the room code with friends!</p>
            </div>
            
            <div class="room-section">
                <h2>Join a Game</h2>
                <input type="text" id="room-code-input" class="room-input" placeholder="ROOM" maxlength="4" />
                <br>
                <button id="join-room-btn" class="room-button">Join Room</button>
            </div>
        </div>
        
        <!-- Room Lobby (when in room) -->
        <div id="room-lobby" style="display: none;">
            <h2>Room Code</h2>
            <div id="room-code-display">ABCD</div>
            <p style="color: #aaa;">Share this code with your friends!</p>
            
            <div class="room-section">
                <h2>Players (<span id="room-player-count">1</span>/8)</h2>
                <div id="player-list">
                    <!-- Players will be added here dynamically -->
                </div>
            </div>
            
            <!-- <div class="room-section"> -->
                <button id="start-game-btn" class="room-button" style="display: none;">Start Game</button>
                <button id="leave-room-btn" class="room-button" style="background: #f44336;">Leave Room</button>
            <!-- </div> -->
        </div>
        
        <!-- Messages -->
        <div id="room-messages"></div>
    </div>
    
    <div id="game-container"></div>
    <div id="respawn-countdown"></div>
    
    <!-- Disconnection Countdown Toast -->
    <div id="disconnect-countdown" class="disconnect-toast">
        <div class="disconnect-title">⚠️ PLAYER DISCONNECTED</div>
        <div id="disconnect-message" class="disconnect-message">Waiting for reconnection...</div>
        <div id="disconnect-timer" class="disconnect-timer">10</div>
        <div class="disconnect-subtext">seconds to rejoin or you win!</div>
    </div>
    
    <!-- Game Start Countdown -->
    <div id="game-start-countdown">
        <div class="countdown-text">Game Starting...</div>
        <div class="countdown-number">3</div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <h1>🏆 Game Over! 🏆</h1>
        <div class="winner-text" id="winner-text">Winner: Player ABC...</div>
        
        <table class="stats-table" id="stats-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Player</th>
                    <th>Kills</th>
                    <th>Deaths</th>
                    <th>K/D</th>
                </tr>
            </thead>
            <tbody id="stats-tbody">
                <!-- Stats will be populated here -->
            </tbody>
        </table>
        
        <div class="game-over-buttons">
            <button id="rematch-btn" class="game-over-btn rematch-btn">Rematch</button>
            <button id="return-lobby-btn" class="game-over-btn lobby-btn">Return to Lobby</button>
        </div>
    </div>
    
    <div id="controls">
        <div>Controls:</div>
        <div>Left/Right: Move</div>
        <div>Up: Jump</div>
        <div>Down: Drop through platforms</div>
        <div>Space: Attack</div>
        <div>Z: Block</div>
        <div>Shift+Arrow: Dash</div>
        <div>Double-tap Arrow: Dash</div>
        <div>P: Toggle Prediction</div>
    </div>
    
    <div id="prediction-debug" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px;">
        <div>Prediction: <span id="prediction-status">ON</span></div>
        <div>Position Error: <span id="position-error">0.0</span>px</div>
        <div>Buffer Size: <span id="buffer-size">0</span></div>
        <div>Last Update: <span id="server-time">0</span>ms ago</div>
        <div>Input Status: <span id="input-status">Normal</span></div>
        <div>Latency: <span id="latency">0ms</span></div>
        <div>Server Tick: <span id="server-tickrate">30fps</span></div>
    </div>
    
    <script>
        // ==================== FIREBASE AUTHENTICATION ====================
        
        // Firebase configuration - Real config from Firebase CLI
        const firebaseConfig = {
            apiKey: "AIzaSyAh2m1SciisBB6EDxmShQJyxW1uAp0Z32I",
            authDomain: "fighter-game-multiplayer.firebaseapp.com", 
            projectId: "fighter-game-multiplayer",
            storageBucket: "fighter-game-multiplayer.firebasestorage.app",
            messagingSenderId: "799099672774",
            appId: "1:799099672774:web:8e080095ca01c28a1cdfc7"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        
        // Authentication state management
        let currentUser = null;
        let authToken = null;
        
        // Authentication UI elements
        const authSection = document.getElementById('auth-section');
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        
        // Room management variables (moved up to avoid initialization errors)
        let currentRoom = null;
        let isHost = false;
        let gameStarted = false;
        
        // Room UI Elements (moved up to avoid initialization errors)
        const roomUI = document.getElementById('room-ui');
        const mainMenu = document.getElementById('main-menu');
        const roomLobby = document.getElementById('room-lobby');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const roomCodeInput = document.getElementById('room-code-input');
        const roomCodeDisplay = document.getElementById('room-code-display');
        const playerList = document.getElementById('player-list');
        const playerCount = document.getElementById('room-player-count');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const roomMessages = document.getElementById('room-messages');
        
        // Game Over UI Elements (moved up to avoid initialization errors)
        const gameOverScreen = document.getElementById('game-over-screen');
        const winnerText = document.getElementById('winner-text');
        const statsTable = document.getElementById('stats-table');
        const statsTbody = document.getElementById('stats-tbody');
        const rematchBtn = document.getElementById('rematch-btn');
        const returnLobbyBtn = document.getElementById('return-lobby-btn');
        
        // Authentication event handlers
        document.addEventListener('DOMContentLoaded', () => {
            setupAuthEventListeners();
            // Ensure clean initial state - show only authentication section
            showAuthSection();
        });
        
        function setupAuthEventListeners() {
            // Guest play
            document.getElementById('guest-play-btn').addEventListener('click', handleGuestPlay);
            
            // Show login/register forms
            document.getElementById('show-login-btn').addEventListener('click', () => showAuthForm('login'));
            document.getElementById('show-register-btn').addEventListener('click', () => showAuthForm('register'));
            
            // Back buttons
            document.getElementById('back-to-auth-btn').addEventListener('click', showAuthSection);
            document.getElementById('back-to-auth-btn2').addEventListener('click', showAuthSection);
            
            // Form submissions
            document.getElementById('login-submit-btn').addEventListener('click', handleLogin);
            document.getElementById('register-submit-btn').addEventListener('click', handleRegister);
            
            // Enter key handlers
            document.getElementById('guest-name-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleGuestPlay();
            });
            document.getElementById('login-password').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleLogin();
            });
            document.getElementById('register-password').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleRegister();
            });
        }
        
        function showAuthSection() {
            console.log('showAuthSection called - showing authentication UI');
            
            // Show authentication section
            if (authSection) {
                authSection.style.setProperty('display', 'block', 'important');
                authSection.style.setProperty('visibility', 'visible', 'important');
                authSection.style.setProperty('opacity', '1', 'important');
                
                // Restore visibility of child elements
                const authChildren = authSection.querySelectorAll('*');
                authChildren.forEach(child => {
                    child.style.removeProperty('display');
                });
                console.log('Showed auth-section and restored', authChildren.length, 'children');
            }
            
            // Hide all other sections
            if (loginForm) {
                loginForm.style.setProperty('display', 'none', 'important');
            }
            if (registerForm) {
                registerForm.style.setProperty('display', 'none', 'important');
            }
            
            // Hide main menu and room lobby
            const mainMenuEl = document.getElementById('main-menu');
            const roomLobbyEl = document.getElementById('room-lobby');
            if (mainMenuEl) {
                mainMenuEl.style.setProperty('display', 'none', 'important');
            }
            if (roomLobbyEl) {
                roomLobbyEl.style.setProperty('display', 'none', 'important');
            }
            
            // Show room UI container but only with auth section
            roomUI.classList.remove('hidden');
            
            console.log('showAuthSection complete - only auth section should be visible');
        }
        
        function showAuthForm(type) {
            authSection.style.setProperty('display', 'none', 'important');
            loginForm.style.setProperty('display', type === 'login' ? 'block' : 'none', 'important');
            registerForm.style.setProperty('display', type === 'register' ? 'block' : 'none', 'important');
            
            // Hide main menu properly
            const mainMenuEl = document.getElementById('main-menu');
            if (mainMenuEl) mainMenuEl.style.setProperty('display', 'none', 'important');
            
            // Get roomLobby safely
            const roomLobby = document.getElementById('room-lobby');
            if (roomLobby) roomLobby.style.setProperty('display', 'none', 'important');
            console.log('Showing auth form:', type);
        }
        
        function showMainMenu() {
            console.log('showMainMenu called - transitioning to main menu');
            
            // Hide all authentication UI components completely
            if (authSection) {
                authSection.style.setProperty('display', 'none', 'important');
                authSection.style.setProperty('visibility', 'hidden', 'important');
                authSection.style.setProperty('opacity', '0', 'important');
                console.log('Hidden auth-section');
            }
            if (loginForm) {
                loginForm.style.setProperty('display', 'none', 'important');
                console.log('Hidden login-form');
            }
            if (registerForm) {
                registerForm.style.setProperty('display', 'none', 'important');
                console.log('Hidden register-form');
            }
            
            // Show main menu and hide room lobby
            const mainMenuElement = document.getElementById('main-menu');
            const roomLobby = document.getElementById('room-lobby');
            
            if (mainMenuElement) {
                mainMenuElement.style.setProperty('display', 'block', 'important');
                console.log('Showed main-menu');
            }
            if (roomLobby) {
                roomLobby.style.setProperty('display', 'none', 'important');
                console.log('Hidden room-lobby');
            }
            
            // Show room UI container
            roomUI.classList.remove('hidden');
            gameStarted = false;
            
            console.log('showMainMenu complete - should show main menu only');
        }
        

        
        // Guest authentication
        async function handleGuestPlay() {
            const displayName = document.getElementById('guest-name-input').value.trim();
            
            if (!displayName || displayName.length < 2) {
                showMessage('Please enter a name (at least 2 characters)', 'error');
                return;
            }
            
            try {
                // Sign in anonymously with Firebase
                const userCredential = await auth.signInAnonymously();
                const user = userCredential.user;
                
                // Update profile with display name
                await user.updateProfile({ displayName: displayName });
                
                // Store guest user data
                await db.collection('users').doc(user.uid).set({
                    displayName: displayName,
                    isGuest: true,
                    isAnonymous: true,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0
                });
                
                // Store in localStorage
                localStorage.setItem('guestDisplayName', displayName);
                localStorage.setItem('guestUserId', user.uid);
                
                currentUser = {
                    uid: user.uid,
                    displayName: displayName,
                    isGuest: true,
                    isAnonymous: true
                };
                
                // Get Firebase ID token for server authentication
                authToken = await user.getIdToken();
                
                console.log('Guest authentication successful:', user.uid);
                showMessage(`Welcome ${displayName}! Playing as guest.`, 'success');
                updateUserInfo(displayName, true);
                
                // Reconnect socket with auth token
                await reconnectSocketWithAuth();
                
                showMainMenu();
                
            } catch (error) {
                console.error('Guest authentication error:', error);
                showMessage('Failed to start guest session: ' + error.message, 'error');
            }
        }
        
        // Login with email/password
        async function handleLogin() {
            const email = document.getElementById('login-email').value.trim();
            const password = document.getElementById('login-password').value;
            
            if (!email || !password) {
                showMessage('Please enter both email and password', 'error');
                return;
            }
            
            try {
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                const user = userCredential.user;
                
                // Update last active timestamp
                await db.collection('users').doc(user.uid).update({
                    lastActive: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                currentUser = {
                    uid: user.uid,
                    email: user.email,
                    displayName: user.displayName,
                    isGuest: false,
                    isAnonymous: false
                };
                
                // Get Firebase ID token for server authentication
                authToken = await user.getIdToken();
                
                console.log('Login successful:', user.uid);
                showMessage(`Welcome back ${user.displayName}!`, 'success');
                updateUserInfo(user.displayName || user.email, false);
                
                // Reconnect socket with auth token
                await reconnectSocketWithAuth();
                
                showMainMenu();
                
            } catch (error) {
                console.error('Login error:', error);
                showMessage('Login failed: ' + error.message, 'error');
            }
        }
        
        // Register new user
        async function handleRegister() {
            const username = document.getElementById('register-username').value.trim();
            const email = document.getElementById('register-email').value.trim();
            const password = document.getElementById('register-password').value;
            
            if (!username || !email || !password) {
                showMessage('Please fill in all fields', 'error');
                return;
            }
            
            if (username.length < 3 || username.length > 20) {
                showMessage('Username must be 3-20 characters', 'error');
                return;
            }
            
            try {
                console.log('Starting registration process...');
                
                // Check if username is available
                console.log('Checking username availability...');
                const usernameDoc = await db.collection('usernames').doc(username.toLowerCase()).get();
                if (usernameDoc.exists) {
                    showMessage('Username already taken', 'error');
                    return;
                }
                console.log('Username available, proceeding...');
                
                console.log('Creating Firebase Auth user...');
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;
                console.log('Firebase Auth user created:', user.uid);
                
                // Update profile with username
                console.log('Updating user profile...');
                await user.updateProfile({ displayName: username });
                console.log('Profile updated successfully');
                
                // Ensure user is fully authenticated and get fresh token
                console.log('Getting fresh auth token...');
                const freshToken = await user.getIdToken(true); // Force refresh
                console.log('Fresh token obtained, user fully authenticated');
                
                // Small delay to ensure auth state propagation
                await new Promise(resolve => setTimeout(resolve, 100));
                console.log('Auth state propagation delay complete');
                
                // Store user data
                console.log('Storing user data in Firestore...');
                await db.collection('users').doc(user.uid).set({
                    username: username,
                    email: email,
                    displayName: username,
                    isGuest: false,
                    isAnonymous: false,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastActive: firebase.firestore.FieldValue.serverTimestamp(),
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0,
                    level: 1,
                    xp: 0
                });
                console.log('User data stored successfully');
                
                // Reserve username
                console.log('Reserving username in Firestore...');
                await db.collection('usernames').doc(username.toLowerCase()).set({
                    uid: user.uid,
                    username: username,
                    reservedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log('Username reserved successfully');
                
                currentUser = {
                    uid: user.uid,
                    email: user.email,
                    displayName: username,
                    isGuest: false,
                    isAnonymous: false
                };
                
                // Get Firebase ID token for server authentication
                authToken = await user.getIdToken();
                
                console.log('Registration successful:', user.uid);
                showMessage(`Welcome ${username}! Account created successfully.`, 'success');
                updateUserInfo(username, false);
                
                // Reconnect socket with auth token
                await reconnectSocketWithAuth();
                
                showMainMenu();
                
            } catch (error) {
                console.error('Registration error:', error);
                showMessage('Registration failed: ' + error.message, 'error');
            }
        }
        
        // Send auth token to server after authentication
        async function reconnectSocketWithAuth() {
            if (!authToken) {
                console.log('No auth token available');
                return;
            }
            
            if (!socket || !socket.connected) {
                console.log('Socket not connected, waiting...');
                return;
            }
            
            console.log('Sending auth token to server...');
            
            // Send auth token to server for authentication
            socket.emit('authenticate', { token: authToken }, (response) => {
                if (response && response.success) {
                    console.log('Server authentication successful:', response.user);
                } else {
                    console.error('Server authentication failed:', response?.error || 'Unknown error');
                }
            });
        }
        
        // Send authentication to server (synchronous version for room operations)
        async function sendAuthToServer() {
            if (!authToken) {
                console.log('No auth token available');
                return false;
            }
            
            if (!socket || !socket.connected) {
                console.log('Socket not connected');
                return false;
            }
            
            return new Promise((resolve) => {
                console.log('Sending auth token to server...');
                socket.emit('authenticate', { token: authToken }, (response) => {
                    if (response && response.success) {
                        console.log('Authentication successful with server');
                        resolve(true);
                    } else {
                        console.error('Authentication failed with server:', response?.error);
                        resolve(false);
                    }
                });
            });
        }
        
        // Utility functions for user info and sign-out
        function updateUserInfo(displayName, isGuest) {
            const userInfoDiv = document.getElementById('authenticated-user-info');
            if (userInfoDiv) {
                const userType = isGuest ? 'Guest Player' : 'Registered Player';
                const icon = isGuest ? '🎮' : '👤';
                userInfoDiv.innerHTML = `
                    ${icon} ${userType}: <strong>${displayName}</strong><br>
                    <a href="#" id="sign-out-link" style="color: #888; text-decoration: underline; font-size: 12px; cursor: pointer;">sign out</a>
                `;
                
                // Re-attach event listener to the new sign-out link
                const signOutLink = document.getElementById('sign-out-link');
                if (signOutLink) {
                    signOutLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        handleSignOut();
                    });
                }
            }
        }
        
        async function handleSignOut() {
            try {
                await auth.signOut();
                currentUser = null;
                authToken = null;
                
                // Clear localStorage
                localStorage.removeItem('guestDisplayName');
                localStorage.removeItem('guestUserId');
                
                showMessage('Signed out successfully', 'success');
                
                // Clear user info first
                const userInfoDiv = document.getElementById('authenticated-user-info');
                if (userInfoDiv) {
                    userInfoDiv.innerHTML = '';
                }
                
                showAuthSection();
                
            } catch (error) {
                console.error('Sign out error:', error);
                showMessage('Failed to sign out: ' + error.message, 'error');
            }
        }
        
        // Listen for auth state changes
        auth.onAuthStateChanged((user) => {
            if (user && !currentUser) {
                // User is signed in but we haven't set currentUser yet
                // This happens on page refresh
                console.log('User found on auth state change:', user.uid);
                
                currentUser = {
                    uid: user.uid,
                    email: user.email,
                    displayName: user.displayName,
                    isGuest: user.isAnonymous,
                    isAnonymous: user.isAnonymous
                };
                
                if (user.isAnonymous) {
                    const savedName = localStorage.getItem('guestDisplayName');
                    if (savedName) {
                        currentUser.displayName = savedName;
                    }
                }
                
                user.getIdToken().then(token => {
                    authToken = token;
                });
                
                // Update user info before showing main menu
                const displayName = currentUser.displayName || currentUser.email || 'User';
                updateUserInfo(displayName, currentUser.isGuest);
                showMainMenu();
            } else if (!user && currentUser) {
                // User signed out
                currentUser = null;
                authToken = null;
                showAuthSection();
            }
        });
        
        // ==================== END FIREBASE AUTHENTICATION ====================

        // Phaser game configuration
        const config = {
            type: Phaser.AUTO,
            width: 1200, // Expanded from 800 to allow fall-off movement
            height: 1000, // Expanded from 600 to allow fall recovery attempts
            parent: 'game-container',
            backgroundColor: '#2c5f2d',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 }, // Server handles gravity
                    debug: false // Server handles collision detection
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // Create the game
        const game = new Phaser.Game(config);

        let cursors;
        let socket;
        let spaceKey;
        let zKey;
        let shiftKey; // Dedicated dash key
        let platforms; // Platform physics group
        
        // Dash input detection variables
        let lastLeftKeyTime = 0;
        let lastRightKeyTime = 0;
        let dashInputCooldown = 0; // Prevent multiple dash triggers
        const DASH_DOUBLE_TAP_WINDOW = 250; // ms
        const DASH_INPUT_COOLDOWN = 100; // ms to prevent multiple triggers
        
        const playerSprites = {};
        const playerHealthBars = {};
        const playerAttackEffects = {};
        let myPlayerId = null;
        let gameState = { players: {} };
        
        // Client-side prediction variables
        let clientPlayerState = null;
        let inputBuffer = [];
        let lastServerUpdate = 0;
        let predictionEnabled = true;
        const PHYSICS_CONSTANTS = {
            GRAVITY: 1200, // Increased for snappier falls
            GROUND_Y: 560,
            FRAME_RATE: 60,
            JUMP_VELOCITY_SINGLE: -550, // Slightly stronger jumps
            JUMP_VELOCITY_DOUBLE: -450
        };

        // ==================== ROOM MANAGEMENT SYSTEM ====================
        

        
        // Room management functions
        function showMessage(message, type = 'info', duration = 5000) {
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 
                                  type === 'warning' ? 'warning-message' : 'success-message';
            messageDiv.textContent = message;
            roomMessages.appendChild(messageDiv);
            
            // Auto-remove message after specified duration
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, duration);
        }
        
        // showMainMenu function is now consolidated in the auth section above
        
        function showRoomLobby(roomCode, hostStatus) {
            // Hide all authentication sections completely
            const authSectionEl = document.getElementById('auth-section');
            const loginFormEl = document.getElementById('login-form');
            const registerFormEl = document.getElementById('register-form');
            const mainMenuEl = document.getElementById('main-menu');
            const roomLobbyEl = document.getElementById('room-lobby');
            
            if (authSectionEl) authSectionEl.style.setProperty('display', 'none', 'important');
            if (loginFormEl) loginFormEl.style.setProperty('display', 'none', 'important');
            if (registerFormEl) registerFormEl.style.setProperty('display', 'none', 'important');
            
            // Hide main menu and show room lobby
            if (mainMenuEl) mainMenuEl.style.setProperty('display', 'none', 'important');
            if (roomLobbyEl) roomLobbyEl.style.setProperty('display', 'block', 'important');
            
            roomCodeDisplay.textContent = roomCode;
            isHost = hostStatus;
            
            // Show start button only for host
            startGameBtn.style.display = isHost ? 'block' : 'none';
            
            console.log('Showing room lobby for room:', roomCode);
        }
        
        function hideRoomUI() {
            roomUI.classList.add('hidden');
            gameStarted = true;
        }
        
        function updatePlayerList(players) {
            playerList.innerHTML = '';
            
            if (players && players.length > 0) {
                players.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-item';
                    if (player.isHost) {
                        playerDiv.classList.add('player-host');
                    }
                    
                    const playerId = player.socketId || player.id;
                    playerDiv.innerHTML = `
                        <span>${player.name || `Player ${playerId.substring(0, 8)}...`}</span>
                        <span>${player.isHost ? '👑 Host' : '🕹️ Player'}</span>
                    `;
                    
                    playerList.appendChild(playerDiv);
                });
                
                playerCount.textContent = players.length;
            } else {
                playerCount.textContent = '0';
            }
        }
        
        async function createRoom() {
            if (!socket) {
                showMessage('Not connected to server', 'error');
                return;
            }
            
            // Ensure authentication before creating room
            if (authToken) {
                console.log('Ensuring authentication before creating room...');
                await sendAuthToServer();
            }
            
            createRoomBtn.disabled = true;
            createRoomBtn.textContent = 'Creating...';
            
            socket.emit('createRoom', (response) => {
                createRoomBtn.disabled = false;
                createRoomBtn.textContent = 'Create Room';
                
                if (response.success) {
                    currentRoom = {
                        code: response.roomCode,
                        isHost: response.isHost,
                        playerCount: response.playerCount
                    };
                    
                    showRoomLobby(response.roomCode, response.isHost);
                    showMessage(`Room ${response.roomCode} created successfully!`, 'success');
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        async function joinRoom() {
            const roomCode = roomCodeInput.value.trim().toUpperCase();
            
            if (!roomCode || roomCode.length !== 4) {
                showMessage('Please enter a 4-letter room code', 'error');
                return;
            }
            
            if (!socket) {
                showMessage('Not connected to server', 'error');
                return;
            }
            
            // Ensure authentication before joining room
            if (authToken) {
                console.log('Ensuring authentication before joining room...');
                await sendAuthToServer();
            }
            
            joinRoomBtn.disabled = true;
            joinRoomBtn.textContent = 'Joining...';
            
            socket.emit('joinRoom', { roomCode }, (response) => {
                joinRoomBtn.disabled = false;
                joinRoomBtn.textContent = 'Join Room';
                
                if (response.success) {
                    currentRoom = {
                        code: response.roomCode,
                        isHost: response.isHost,
                        playerCount: response.playerCount
                    };
                    
                    showRoomLobby(response.roomCode, response.isHost);
                    showMessage(`Joined room ${response.roomCode}!`, 'success');
                    roomCodeInput.value = '';
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        function leaveRoom() {
            if (!socket || !currentRoom) return;
            
            socket.emit('leaveRoom', (response) => {
                if (response.success) {
                    currentRoom = null;
                    isHost = false;
                    if (window.gameScene) {
                        window.gameScene.hideDisconnectionCountdown();
                    }
                    showMainMenu();
                    showMessage('Left room successfully', 'success');
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
        
        function startGame() {
            if (!isHost) {
                showMessage('Only the host can start the game', 'error');
                return;
            }
            
            // Disable the start button to prevent multiple clicks
            startGameBtn.disabled = true;
            startGameBtn.textContent = 'Starting...';
            
            // Emit startGame event to server
            socket.emit('startGame', (response) => {
                if (response.success) {
                    // Game start countdown will be handled by socket events
                    console.log('Game start initiated:', response.message);
                } else {
                    showMessage(response.error, 'error');
                    // Re-enable the button if there was an error
                    startGameBtn.disabled = false;
                    startGameBtn.textContent = 'Start Game';
                }
            });
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            createRoomBtn.addEventListener('click', createRoom);
            joinRoomBtn.addEventListener('click', joinRoom);
            leaveRoomBtn.addEventListener('click', leaveRoom);
            startGameBtn.addEventListener('click', startGame);
            
            // Game Over button event listeners
            rematchBtn.addEventListener('click', handleRematch);
            returnLobbyBtn.addEventListener('click', handleReturnToLobby);
            
            // Handle Enter key in room code input
            roomCodeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    joinRoom();
                }
            });
            
            // Auto-uppercase room code input
            roomCodeInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase();
            });
        });
        


        // ==================== END ROOM MANAGEMENT SYSTEM ====================

        function preload() {
            // Create simple colored rectangles for sprites - extend background
            this.add.graphics()
                .fillStyle(0x333333)
                .fillRect(0, 0, 1200, 1000);
                
            // Removed play area outline for cleaner look
                
                // Removed death boundary line for cleaner look
                    
                // Bottom area now matches background - simple and clean
                this.add.graphics()
                    .fillStyle(0x333333) // Same grey as main background
                    .fillRect(0, 600, 1200, 400); // Fill entire bottom area with background color
        }

        // Platforms are now server-side only - no client collision callbacks needed

        function create() {
            // Create platform physics group (static - they don't move)
            platforms = this.physics.add.staticGroup();
            
            // Create all platforms from configuration
            if (window.PlatformConfig) {
                const { PLATFORMS, PLATFORM_COLORS } = window.PlatformConfig;
                
                PLATFORMS.forEach(platformData => {
                    // Create platform sprite with proper color
                    const color = PLATFORM_COLORS[platformData.type];
                    const platform = this.add.rectangle(
                        platformData.x + 200, // Offset by 200px to center in 1200px canvas
                        platformData.y,
                        platformData.width,
                        platformData.height,
                        color
                    );
                    
                    // Add physics body to the platform
                    platforms.add(platform);
                    
                    // Store platform data for collision detection
                    platform.platformData = platformData;
                });
                
                console.log(`Created ${PLATFORMS.length} platforms`);
            } else {
                console.error('Platform configuration not loaded!');
                // Fallback to original ground
                this.add.rectangle(400, 580, 800, 40, 0x8B4513);
            }
            
            // Background elements removed for cleaner look
            
            cursors = this.input.keyboard.createCursorKeys();
            spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            zKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
            
            // Dash input keys
            shiftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);
            
            // Set camera bounds to show the full expanded area
            this.cameras.main.setBounds(0, 0, 1200, 1000);
            // Center camera on the main play area initially  
            this.cameras.main.setScroll(0, 0);
            
            // Store reference to scene for collision callbacks
            window.gameScene = this;
            
            // Initialize disconnection countdown interval tracker
            this.disconnectionCountdownInterval = null;

            // DOM-based disconnection countdown helpers
            this.showDisconnectionCountdown = (event) => {
                const toast      = document.getElementById('disconnect-countdown');
                const messageEl  = document.getElementById('disconnect-message');
                const timerEl    = document.getElementById('disconnect-timer');

                let timeLeft = event.gracePeriodSeconds || 10;

                messageEl.textContent = event.message || 'Waiting for reconnection...';
                timerEl.textContent   = timeLeft;
                toast.style.display   = 'block';

                // Clear any previous interval
                if (this.disconnectionCountdownInterval) {
                    clearInterval(this.disconnectionCountdownInterval);
                }

                // Start countdown
                this.disconnectionCountdownInterval = setInterval(() => {
                    timeLeft--;
                    timerEl.textContent = timeLeft;

                    // Simple pulse effect for urgency
                    if (timeLeft <= 5) {
                        toast.style.transform = 'translate(-50%, -50%) scale(1.05)';
                        setTimeout(() => {
                            toast.style.transform = 'translate(-50%, -50%) scale(1)';
                        }, 150);
                    }

                    // Auto-hide when finished
                    if (timeLeft <= 0) {
                        this.hideDisconnectionCountdown();
                    }
                }, 1000);
            };

            this.hideDisconnectionCountdown = () => {
                const toast = document.getElementById('disconnect-countdown');
                toast.style.display = 'none';

                if (this.disconnectionCountdownInterval) {
                    clearInterval(this.disconnectionCountdownInterval);
                    this.disconnectionCountdownInterval = null;
                }
            };
            
            // Prediction toggle key
            const pKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
            pKey.on('down', () => {
                predictionEnabled = !predictionEnabled;
                console.log(`Prediction toggled: ${predictionEnabled ? 'ON' : 'OFF'}`);
                if (!predictionEnabled) {
                    clientPlayerState = null; // Reset client state
                    console.log('Client state reset - prediction disabled');
                    // Force sprite to server position
                    if (myPlayerId && playerSprites[myPlayerId] && gameState.players[myPlayerId]) {
                        const serverPlayer = gameState.players[myPlayerId];
                        playerSprites[myPlayerId].setPosition(serverPlayer.x + 200, serverPlayer.y);
                    }
                } else {
                    console.log('Prediction enabled - client state will reinitialize');
                }
                updateDebugPanel();
            });
            
            // Initialize socket connection with auth token
            socket = io({
                auth: {
                    token: authToken
                }
            });
            myPlayerId = socket.id;
            
            socket.on('gameState', (newGameState) => {
                gameState = newGameState;
                
                // Client-side prediction reconciliation
                if (predictionEnabled && myPlayerId) {
                    reconcileWithServer(newGameState);
                }
                
                updatePlayerCount();
                updatePlayerSprites.call(this);
                updateUI();
            });
            
            // Handle optimized platform data (sent separately)
            socket.on('platformData', (platformData) => {
                console.log(`[OPTIMIZATION] Received platform data for room ${platformData.roomCode}`);
                gameState.platforms = platformData.platforms;
                // Platforms are static and already rendered in create() - no need to re-render
            });
            
            socket.on('connect', () => {
                myPlayerId = socket.id;
                console.log(`[CONNECTION] Connected with socket ID: ${socket.id}`);
                
                // Measure initial connection latency
                const connectionStart = Date.now();
                socket.emit('ping', connectionStart);
            });
            
            // Latency measurement for debugging
            socket.on('pong', (timestamp) => {
                const latency = Date.now() - timestamp;
                console.log(`[LATENCY] Round-trip time: ${latency}ms`);
                
                // Update debug panel with latency info
                const latencyElement = document.getElementById('latency');
                if (latencyElement) {
                    latencyElement.textContent = `${latency}ms`;
                    
                    // Color-code latency for visual feedback
                    if (latency < 50) {
                        latencyElement.style.color = '#66ff66'; // Green - excellent
                    } else if (latency < 100) {
                        latencyElement.style.color = '#ffff66'; // Yellow - good
                    } else if (latency < 200) {
                        latencyElement.style.color = '#ff9966'; // Orange - fair
                    } else {
                        latencyElement.style.color = '#ff6666'; // Red - poor
                    }
                }
            });
            
            // Listen for jump events for visual effects
            socket.on('playerJump', (jumpEvent) => {
                handleJumpEvent.call(this, jumpEvent);
            });
            
            // Listen for dash events for visual effects
            socket.on('playerDash', (dashEvent) => {
                handleDashEvent.call(this, dashEvent);
            });
            
            // Listen for death events
            socket.on('playerDeath', (deathEvent) => {
                handlePlayerDeath.call(this, deathEvent);
            });
            
            // Listen for respawn events
            socket.on('playerRespawn', (respawnEvent) => {
                handlePlayerRespawn.call(this, respawnEvent);
            });
            
            // Listen for elimination events
            socket.on('playerEliminated', (eliminationEvent) => {
                handlePlayerElimination.call(this, eliminationEvent);
            });
            
            // Listen for match end events
            socket.on('matchEnd', (matchEndEvent) => {
                handleMatchEnd.call(this, matchEndEvent);
            });
            
            // Listen for match reset events
            socket.on('matchReset', (resetEvent) => {
                handleMatchReset.call(this, resetEvent);
            });
            
            // Listen for invincibility end events
            socket.on('playerInvincibilityEnd', (invincibilityEvent) => {
                handleInvincibilityEnd.call(this, invincibilityEvent);
            });
            
            // ==================== ROOM EVENT HANDLERS ====================
            
            // Listen for new players joining the room
            socket.on('playerJoinedRoom', (event) => {
                if (currentRoom) {
                    const playerName = event.playerName || `Player ${event.socketId.substring(0, 8)}...`;
                    showMessage(`${playerName} joined the room (${event.playerCount}/8)`, 'success');
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                }
            });
            
            // Listen for players leaving the room
            socket.on('playerLeftRoom', (event) => {
                if (currentRoom) {
                    let message = `Player left the room (${event.playerCount}/8)`;
                    
                    if (event.reason === 'disconnect') {
                        message = `Player disconnected (${event.playerCount}/8)`;
                    }
                    
                    showMessage(message, 'info');
                    
                    // Update host status if needed
                    if (event.newHostId === socket.id) {
                        isHost = true;
                        startGameBtn.style.display = 'block';
                        showMessage('You are now the host!', 'success');
                    }
                    
                    // Request updated room info
                    socket.emit('getRoomInfo', (roomInfo) => {
                        if (roomInfo.success) {
                            updatePlayerList(roomInfo.players);
                        }
                    });
                }
            });
            
            // Listen for room closure
            socket.on('roomClosed', (event) => {
                currentRoom = null;
                isHost = false;
                gameStarted = false;
                
                // Hide game over screen if visible
                hideGameOverScreen();
                
                // Hide disconnection countdown if visible
                if (window.gameScene) {
                    window.gameScene.hideDisconnectionCountdown();
                }
                
                // Show main menu
                roomUI.style.display = 'block';
                showMainMenu();
                
                // Show appropriate message
                const message = event.message || `Room closed: ${event.reason || 'Unknown reason'}`;
                showMessage(message, 'error');
            });
            
            // Listen for room errors
            socket.on('roomError', (error) => {
                showMessage(error.message, 'error');
            });
            
            // ==================== GAME START EVENT HANDLERS ====================
            
            // Listen for game start countdown
            socket.on('gameStartCountdown', (event) => {
                console.log('Game start countdown:', event.countdown);
                
                const countdownEl = document.getElementById('game-start-countdown');
                const countdownNumberEl = countdownEl.querySelector('.countdown-number');
                
                // Hide room UI during countdown
                roomUI.style.display = 'none';
                
                // Show countdown with current number
                countdownNumberEl.textContent = event.countdown;
                countdownEl.style.display = 'block';
                
                // Play countdown sound effect (if available)
                // You could add audio here: new Audio('countdown.mp3').play();
            });
            
            // Listen for game started
            socket.on('gameStarted', (event) => {
                console.log('Game started!', event);
                
                const countdownEl = document.getElementById('game-start-countdown');
                const countdownNumberEl = countdownEl.querySelector('.countdown-number');
                const countdownTextEl = countdownEl.querySelector('.countdown-text');
                
                // Show "FIGHT!" message
                countdownTextEl.textContent = 'FIGHT!';
                countdownNumberEl.textContent = '';
                countdownEl.style.color = '#FF6B35'; // Orange color for "FIGHT!"
                
                // Hide countdown after 1 second and start game
                setTimeout(() => {
                    countdownEl.style.display = 'none';
                    
                    // Reset countdown display for next time
                    countdownTextEl.textContent = 'Game Starting...';
                    countdownEl.style.color = '#4CAF50';
                    
                    // Hide room UI and start the game
                    hideRoomUI();
                    gameStarted = true;
                    
                    // Reset the start button for next game
                    startGameBtn.disabled = false;
                    startGameBtn.textContent = 'Start Game';
                    
                    showMessage('Game started! Fight!', 'success');
                }, 1000);
                
                // Play game start sound effect (if available)
                // You could add audio here: new Audio('fight.mp3').play();
            });
            
            // ==================== END GAME START EVENT HANDLERS ====================
            
            // ==================== GAME OVER EVENT HANDLERS ====================
            
            // Listen for game over event
            socket.on('gameOver', (gameOverData) => {
                console.log('Game Over received:', gameOverData);
                if (window.gameScene) {
                    window.gameScene.hideDisconnectionCountdown();
                }
                showGameOverScreen(gameOverData);
            });
            
            // Listen for rematch starting
            socket.on('rematchStarting', (event) => {
                console.log('Rematch starting:', event);
                hideGameOverScreen();
                
                // Reset the rematch button
                rematchBtn.disabled = false;
                rematchBtn.textContent = 'Rematch';
                
                showMessage('Rematch starting!', 'success');
            });
            
            // Listen for return to lobby response
            socket.on('returnedToLobby', (event) => {
                console.log('Returned to lobby:', event);
                hideGameOverScreen();
                // Show room UI again
                roomUI.style.display = 'block';
                showRoomLobby(event.roomCode, event.isHost);
                currentRoom = { code: event.roomCode };
                isHost = event.isHost;
                
                console.log(`Returned to lobby - isHost: ${isHost}, startGameBtn display: ${startGameBtn.style.display}`);
                
                // Request updated room info to refresh player list
                socket.emit('getRoomInfo', (roomInfo) => {
                    if (roomInfo.success) {
                        updatePlayerList(roomInfo.players);
                    }
                });
            });
            
            // Listen for room joined event (also triggered on return to lobby)
            socket.on('roomJoined', (event) => {
                console.log('Room joined/rejoined:', event);
                
                if (event.rejoined && event.gameInProgress) {
                    // Player rejoined an active game - don't show room UI, just continue playing
                    console.log('Rejoined active game - continuing where left off');
                    currentRoom = { code: event.roomCode };
                    isHost = event.isHost;
                    gameStarted = true;
                    
                    // Hide any UI that might be visible
                    hideMainMenu();
                    hideGameOverScreen();
                    roomUI.style.display = 'none';
                    
                    showMessage('Welcome back! You have rejoined the game.', 'success', 3000);
                } else {
                    // Normal room join or return to lobby
                    roomUI.style.display = 'block';
                    showRoomLobby(event.roomCode, event.isHost);
                    currentRoom = { code: event.roomCode };
                    isHost = event.isHost;
                    
                    console.log(`Room joined/returned to lobby - isHost: ${isHost}, showing start button: ${isHost ? 'yes' : 'no'}`);
                    
                    // Update player list if provided
                    if (event.players) {
                        updatePlayerList(event.players);
                    }
                }
            });
            
            // Listen for other players returning to lobby
            socket.on('playerReturnedToLobby', (event) => {
                console.log('Player returned to lobby:', event);
                
                // Update player list if we're in the same room and showing lobby
                if (currentRoom && currentRoom.code === event.roomCode && roomLobby.style.display !== 'none') {
                    updatePlayerList(event.players);
                    playerCount.textContent = event.playerCount;
                }
            });
            
            // Listen for player disconnection grace period
            socket.on('playerDisconnectedGracePeriod', (event) => {
                console.log('Player disconnected - grace period started:', event);
                if (window.gameScene) {
                    window.gameScene.showDisconnectionCountdown(event);
                }
            });
            
            // Listen for player rejoining during grace period
            socket.on('playerRejoinedGame', (event) => {
                console.log('Player rejoined game:', event);
                if (window.gameScene) {
                    window.gameScene.hideDisconnectionCountdown();
                }
                showMessage(event.message, 'success', 3000);
            });
            
            // Listen for host transfer events
            socket.on('hostTransferred', (event) => {
                console.log('Host transferred:', event);
                if (event.newHostId === socket.id) {
                    isHost = true;
                    startGameBtn.style.display = 'block';
                    showMessage(event.message, 'success', 5000);
                }
            });
            
            // ==================== END GAME OVER EVENT HANDLERS ====================
            
            // ==================== END ROOM EVENT HANDLERS ====================
        }

        function updatePlayerSprites() {
            // Remove sprites for disconnected players
            for (const id in playerSprites) {
                if (!gameState.players[id]) {
                    playerSprites[id].destroy();
                    playerHealthBars[id].background.destroy();
                    playerHealthBars[id].fill.destroy();
                    if (playerAttackEffects[id]) {
                        playerAttackEffects[id].destroy();
                    }
                    delete playerSprites[id];
                    delete playerHealthBars[id];
                    delete playerAttackEffects[id];
                }
            }
            
            // Update or create sprites for connected players
            for (const id in gameState.players) {
                const player = gameState.players[id];
                
                if (!playerSprites[id]) {
                    // Create new player sprite with physics body
                    const color = id === myPlayerId ? 0xff0000 : 0x0000ff;
                    playerSprites[id] = this.add.rectangle(player.x + 200, player.y, 40, 60, color); // Offset by 200px
                    
                    // Store player ID on sprite for reference
                    playerSprites[id].playerId = id;
                    
                    // Create health bar background
                    const healthBarBg = this.add.rectangle(player.x + 200, player.y - 40, 50, 8, 0x333333);
                    const healthBarFill = this.add.rectangle(player.x + 200, player.y - 40, 48, 6, 0x00ff00);
                    
                    playerHealthBars[id] = {
                        background: healthBarBg,
                        fill: healthBarFill
                    };
                    
                    // Create attack effect (initially invisible)
                    playerAttackEffects[id] = this.add.circle(player.x + 200, player.y, 35, 0xffff00, 0.6);
                    playerAttackEffects[id].setVisible(false);
                } else {
                    // Update existing sprite position
                    // For local player: only use server position if prediction is disabled
                    if (id === myPlayerId && predictionEnabled && clientPlayerState) {
                        // Use predicted position for local player
                        playerSprites[id].setPosition(clientPlayerState.x + 200, clientPlayerState.y);
                    } else {
                        // Use server position for other players or when prediction is off
                        playerSprites[id].setPosition(player.x + 200, player.y);
                    }
                    
                    // Update player color based on state
                    let playerColor = id === myPlayerId ? 0xff0000 : 0x0000ff;
                    let playerAlpha = 1.0;
                    
                    if (player.eliminated) {
                        playerColor = 0x333333; // Dark gray when eliminated
                        playerAlpha = 0.5;
                    } else if (player.isDead) {
                        playerColor = 0x666666; // Gray when dead
                        playerAlpha = 0.3;
                    } else if (player.isInvincible) {
                        playerColor = 0x00ffff; // Cyan when invincible
                        playerAlpha = 0.7 + Math.sin(Date.now() * 0.01) * 0.3; // Blinking effect
                    } else if (player.blocking) {
                        playerColor = 0xffff00; // Yellow when blocking
                    } else if (player.health <= 0) {
                        playerColor = 0x666666; // Gray when health is 0
                    }
                    
                    playerSprites[id].setFillStyle(playerColor);
                    playerSprites[id].setAlpha(playerAlpha);
                    
                    // Update health bar position and fill
                    // Keep health bar position consistent with sprite position
                    const healthBarX = (id === myPlayerId && predictionEnabled && clientPlayerState) ? 
                        clientPlayerState.x + 200 : player.x + 200;
                    const healthBarY = (id === myPlayerId && predictionEnabled && clientPlayerState) ? 
                        clientPlayerState.y - 40 : player.y - 40;
                    
                    playerHealthBars[id].background.x = healthBarX;
                    playerHealthBars[id].background.y = healthBarY;
                    playerHealthBars[id].fill.x = healthBarX;
                    playerHealthBars[id].fill.y = healthBarY;
                    
                    // Update health bar width based on health
                    const healthPercent = player.health / 100;
                    playerHealthBars[id].fill.scaleX = healthPercent;
                    
                    // Update health bar color based on health
                    if (healthPercent > 0.6) {
                        playerHealthBars[id].fill.setFillStyle(0x00ff00);
                    } else if (healthPercent > 0.3) {
                        playerHealthBars[id].fill.setFillStyle(0xffff00);
                    } else {
                        playerHealthBars[id].fill.setFillStyle(0xff0000);
                    }
                    
                    // Update attack effect
                    if (player.attacking && playerAttackEffects[id]) {
                        playerAttackEffects[id].x = player.x + 200; // Add 200px offset
                        playerAttackEffects[id].y = player.y;
                        playerAttackEffects[id].setVisible(true);
                    } else if (playerAttackEffects[id]) {
                        playerAttackEffects[id].setVisible(false);
                    }
                }
            }
        }

        function updatePlayerCount() {
            const count = Object.keys(gameState.players).length;
            document.getElementById('player-count').textContent = `Players: ${count}`;
        }

        let lastUIUpdate = 0;
        let lastPlayerState = {};
        const UI_UPDATE_INTERVAL = 50; // Update UI only every 50ms
        
        function updateUI() {
            const now = Date.now();
            const myPlayer = gameState.players[myPlayerId];
            
            if (!myPlayer) return;
            
            // Check if player state has actually changed
            const currentState = {
                health: myPlayer.health,
                lives: myPlayer.lives,
                eliminated: myPlayer.eliminated,
                isDead: myPlayer.isDead,
                isInvincible: myPlayer.isInvincible
            };
            
            const stateChanged = JSON.stringify(currentState) !== JSON.stringify(lastPlayerState);
            
            // Throttle UI updates unless state changed
            if (!stateChanged && now - lastUIUpdate < UI_UPDATE_INTERVAL) {
                return;
            }
            
            lastUIUpdate = now;
            lastPlayerState = currentState;
            
            document.getElementById('health').textContent = `Health: ${myPlayer.health}`;
            document.getElementById('lives').textContent = `Lives: ${myPlayer.lives}`;
            
            // Update match status
            const statusElement = document.getElementById('match-status');
            if (myPlayer.eliminated) {
                statusElement.textContent = 'ELIMINATED - Spectating';
                statusElement.style.color = '#ff6666';
            } else if (myPlayer.isDead) {
                statusElement.textContent = 'RESPAWNING...';
                statusElement.style.color = '#ffff66';
            } else if (myPlayer.isInvincible) {
                statusElement.textContent = 'INVINCIBLE';
                statusElement.style.color = '#66ffff';
            } else {
                statusElement.textContent = '';
            }
        }



        function update() {
            const currentTime = Date.now();
            
            // Dash input detection system
            let dashDirection = null; // null, 'left', or 'right'
            
            // Update dash input cooldown
            if (dashInputCooldown > 0) {
                dashInputCooldown -= 16.67; // Approximate frame time (60fps)
            }
            
            // Check for dedicated dash key (Shift) + direction
            if (Phaser.Input.Keyboard.JustDown(shiftKey) && dashInputCooldown <= 0) {
                if (cursors.left.isDown) {
                    dashDirection = 'left';
                    dashInputCooldown = DASH_INPUT_COOLDOWN;
                } else if (cursors.right.isDown) {
                    dashDirection = 'right';
                    dashInputCooldown = DASH_INPUT_COOLDOWN;
                }
            }
            
            // Check for double-tap dash (left/right keys)
            if (dashInputCooldown <= 0) {
                // Left key double-tap detection
                if (Phaser.Input.Keyboard.JustDown(cursors.left)) {
                    if (currentTime - lastLeftKeyTime <= DASH_DOUBLE_TAP_WINDOW) {
                        dashDirection = 'left';
                        dashInputCooldown = DASH_INPUT_COOLDOWN;
                    }
                    lastLeftKeyTime = currentTime;
                }
                
                // Right key double-tap detection  
                if (Phaser.Input.Keyboard.JustDown(cursors.right)) {
                    if (currentTime - lastRightKeyTime <= DASH_DOUBLE_TAP_WINDOW) {
                        dashDirection = 'right';
                        dashInputCooldown = DASH_INPUT_COOLDOWN;
                    }
                    lastRightKeyTime = currentTime;
                }
            }
            
            const inputs = {
                left: cursors.left.isDown,
                right: cursors.right.isDown,
                jump: Phaser.Input.Keyboard.JustDown(cursors.up),
                attack: Phaser.Input.Keyboard.JustDown(spaceKey),
                block: zKey.isDown,
                down: cursors.down.isDown,
                dash: dashDirection // Add dash direction to inputs
            };
            
            // Client-side prediction for smooth gameplay
            if (predictionEnabled && myPlayerId && gameState.players[myPlayerId]) {
                // Initialize client state if needed
                if (!clientPlayerState) {
                    initializeClientPlayerState();
                }
                
                // Apply inputs immediately on client for responsiveness
                applyClientSidePrediction(inputs);
                
                // Buffer input for server reconciliation
                bufferInput(inputs);
            }
            
            socket.emit('input', inputs);
        }
        
        // Client-side prediction functions
        function initializeClientPlayerState() {
            const serverPlayer = gameState.players[myPlayerId];
            if (!serverPlayer) return;
            
            // Perfect sync with server state
            clientPlayerState = {
                x: serverPlayer.x,
                y: serverPlayer.y,
                velocityX: serverPlayer.velocityX || 0,
                velocityY: serverPlayer.velocityY || 0,
                isGrounded: serverPlayer.isGrounded !== undefined ? serverPlayer.isGrounded : true,
                jumpsRemaining: serverPlayer.jumpsRemaining || 2,
                lastJumpTime: serverPlayer.lastJumpTime || 0,
                blocking: serverPlayer.blocking || false,
                health: serverPlayer.health,
                droppingTimer: 0, // frames left to ignore one-way collisions
                isDashing: false, // New for dash state
                dashDirection: 0, // New for dash direction
                dashStartTime: 0, // New for dash start time
                lastDashTime: 0, // New for last dash time
                dashVelocity: 0 // New for dash velocity
            };
            
            // Force immediate position sync to eliminate initial error
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                updateLocalPlayerHealthBar();
            }
        }
        
        function updateLocalPlayerHealthBar() {
            if (predictionEnabled && myPlayerId && clientPlayerState && playerHealthBars[myPlayerId]) {
                const healthBarX = clientPlayerState.x + 200; // Add 200px offset
                const healthBarY = clientPlayerState.y - 40;
                
                playerHealthBars[myPlayerId].background.x = healthBarX;
                playerHealthBars[myPlayerId].background.y = healthBarY;
                playerHealthBars[myPlayerId].fill.x = healthBarX;
                playerHealthBars[myPlayerId].fill.y = healthBarY;
            }
        }

        // Utility: returns true if we should ignore one-way platforms this frame
        function isDroppingThrough() {
            return clientPlayerState && clientPlayerState.droppingTimer && clientPlayerState.droppingTimer > 0;
        }

        function getClientGroundState(player, ignoreOneWay) {
            const { PLATFORMS, PLATFORM_TYPES, PlatformUtils } = window.PlatformConfig;

            let isGrounded = false;
            let groundY = PHYSICS_CONSTANTS.GROUND_Y;
            let landedPlatform = null;

            // EXACT SERVER MATCH: Use the same collision logic as server
            for (const platform of PLATFORMS) {
                const playerBounds = PlatformUtils.getPlayerBounds(player);
                const platformBounds = PlatformUtils.getPlatformBounds(platform);
                
                // Check if player is horizontally aligned with platform (exact server logic)
                const isHorizontallyOverlapping = playerBounds.left < platformBounds.right && 
                                                 playerBounds.right > platformBounds.left;
                
                if (isHorizontallyOverlapping) {
                    const platformTop = platform.y - platform.height / 2;
                    const playerBottom = player.y + 30; // Player height/2 = 30px (exact server match)
                    
                    // Check if player is close enough to platform top (exact server tolerance)
                    const distanceToTop = playerBottom - platformTop;
                    const isNearPlatform = distanceToTop >= -20 && distanceToTop <= 20; // 20px tolerance
                    
                    if (isNearPlatform && player.velocityY >= 0) {
                        // For one-way platforms, handle dropping logic
                        if (platform.type === PLATFORM_TYPES.ONE_WAY) {
                            // Skip collision if ignoring one-way or actively dropping
                            if (ignoreOneWay || isDroppingThrough()) {
                                continue;
                            }
                            
                            if (player.y < platformTop) { // Player center is above platform top
                                isGrounded = true;
                                groundY = PlatformUtils.getPlayerStandingY(platform);
                                landedPlatform = platform;
                                break;
                            }
                        } else {
                            // Solid platforms - can land from any direction (exact server logic)
                            isGrounded = true;
                            groundY = PlatformUtils.getPlayerStandingY(platform);
                            landedPlatform = platform;
                            break;
                        }
                    }
                }
            }

            return { isGrounded, groundY, platform: landedPlatform };
        }
 
        function applyClientSidePrediction(inputs) {
            // Use actual frame timing for accurate physics
            const now = Date.now();
            if (!this.lastPredictionTime) this.lastPredictionTime = now;
            const actualDeltaTime = (now - this.lastPredictionTime) / 1000; // Convert to seconds
            const deltaTime = Math.min(actualDeltaTime, 1/30); // Cap at 30fps to prevent large jumps
            this.lastPredictionTime = now;
            
            // Apply same anti-cheat logic as server: prevent conflicting inputs
            let inputsCancelled = false;
            if (inputs.left && inputs.right) {
                inputs.left = false;
                inputs.right = false;
                inputsCancelled = true;
            }
            
            // Update debug panel input status
            const inputStatusElement = document.getElementById('input-status');
            if (inputStatusElement) {
                if (inputsCancelled) {
                    inputStatusElement.textContent = 'CANCELLED (L+R)';
                    inputStatusElement.style.color = '#ff6666';
                } else {
                    inputStatusElement.textContent = 'Normal';
                    inputStatusElement.style.color = '#66ff66';
                }
            }
            
            // SIMPLIFIED: More conservative movement prediction
            const moveSpeed = clientPlayerState.blocking ? 3 : 6; // Match server MOVEMENT_SPEED
            
            // Conservative movement handling to reduce divergence
            if (inputs.left) {
                clientPlayerState.x -= moveSpeed;
                clientPlayerState.velocityX = -moveSpeed;
            } else if (inputs.right) {
                clientPlayerState.x += moveSpeed;
                clientPlayerState.velocityX = moveSpeed;
            } else {
                clientPlayerState.velocityX = 0;
            }
            
            // Jump prediction with exact server matching
            if (inputs.jump && validateClientJump(now)) {
                performClientJump(now);
            }
            
            // Dash prediction with client-side validation
            if (inputs.dash && validateClientDash(now)) {
                performClientDash(inputs.dash, now);
            }
            
            // IMPROVED VERTICAL PHYSICS: Better jump handling
            const serverPlayer = gameState.players[myPlayerId];
            
            // Safety check - if no server data, skip prediction this frame
            if (!serverPlayer) {
                return;
            }
            
            // Only override client physics for extreme disagreements or when grounded
            const yDifference = Math.abs(clientPlayerState.y - serverPlayer.y);
            const shouldTrustServer = yDifference > 100 || // Extreme disagreement
                                     (serverPlayer.isGrounded && yDifference > 50); // Server says grounded with big difference
            
            if (shouldTrustServer) {
                // Large disagreement - gradually sync to server
                const yDiff = serverPlayer.y - clientPlayerState.y;
                clientPlayerState.y += yDiff * 0.3; // Moderate correction
                clientPlayerState.velocityY = serverPlayer.velocityY || 0;
                clientPlayerState.isGrounded = serverPlayer.isGrounded;
                clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
            } else {
                // Normal prediction for small differences
                const ignoreOneWayNow = inputs.down || isDroppingThrough();
                let groundState = getClientGroundState(clientPlayerState, ignoreOneWayNow);

                // Handle drop-through for one-way platforms
                const wantsToDrop = inputs.down && groundState.isGrounded &&
                                    groundState.platform && groundState.platform.type === window.PlatformConfig.PLATFORM_TYPES.ONE_WAY;

                if (wantsToDrop) {
                    clientPlayerState.velocityY = Math.max(clientPlayerState.velocityY, 200);
                    clientPlayerState.droppingTimer = 12;
                    clientPlayerState.isGrounded = false;
                } else {
                    // Decrement dropping timer
                    if (clientPlayerState.droppingTimer && clientPlayerState.droppingTimer > 0) {
                        clientPlayerState.droppingTimer--;
                    }

                    // Apply gravity and vertical movement
                    if (!groundState.isGrounded) {
                        // Apply gravity consistently for airborne movement
                        clientPlayerState.velocityY += PHYSICS_CONSTANTS.GRAVITY * deltaTime;
                        
                        // Cap maximum fall speed for more predictable physics
                        const maxFallSpeed = 800;
                        if (clientPlayerState.velocityY > maxFallSpeed) {
                            clientPlayerState.velocityY = maxFallSpeed;
                        }
                        
                        clientPlayerState.y += clientPlayerState.velocityY * deltaTime;
                        clientPlayerState.isGrounded = false;
                    } else {
                        // Grounded - stop vertical movement and position exactly
                        clientPlayerState.y = groundState.groundY;
                        clientPlayerState.velocityY = 0;
                        clientPlayerState.isGrounded = true;
                        clientPlayerState.jumpsRemaining = 2;
                    }
                }
            }
            
            // Update blocking state
            clientPlayerState.blocking = inputs.block;
            
            // Allow free movement beyond boundaries for fall-off deaths
            // No horizontal clamping - players can now fall off the sides
            
            // Apply predicted position to sprite
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y); // Add 200px offset
                updateLocalPlayerHealthBar();
            }
        }
        
        function validateClientJump(currentTime) {
            if (!clientPlayerState || clientPlayerState.health <= 0) return false;
            if (clientPlayerState.jumpsRemaining <= 0) return false;
            if (currentTime - clientPlayerState.lastJumpTime < 250) return false; // Increased cooldown
            
            // Prevent impossible jumps - if falling too fast, deny jump
            if (clientPlayerState.velocityY > 300) return false;
            
            return true;
        }
        
        function performClientJump(currentTime) {
            const jumpVelocity = clientPlayerState.jumpsRemaining === 2 ? 
                PHYSICS_CONSTANTS.JUMP_VELOCITY_SINGLE : 
                PHYSICS_CONSTANTS.JUMP_VELOCITY_DOUBLE;
            
            clientPlayerState.velocityY = jumpVelocity;
            clientPlayerState.jumpsRemaining--;
            clientPlayerState.isGrounded = false;
            clientPlayerState.lastJumpTime = currentTime;
        }
        
        function validateClientDash(currentTime) {
            if (!clientPlayerState || clientPlayerState.health <= 0) return false;
            if (dashInputCooldown > 0) return false; // Prevent multiple dash triggers
            if (clientPlayerState.isDashing) return false; // Prevent dash while already dashing
            if (currentTime - (clientPlayerState.lastDashTime || 0) < 350) return false; // Dash cooldown (reduced from 500)
            return true;
        }

        function performClientDash(direction, currentTime) {
            const dashVelocity = 900; // Match server DASH_VELOCITY (increased from 300)
            const dashDirection = direction === 'left' ? -1 : 1;
            
            // Apply dash physics immediately
            clientPlayerState.isDashing = true;
            clientPlayerState.dashDirection = dashDirection;
            clientPlayerState.dashStartTime = currentTime;
            clientPlayerState.lastDashTime = currentTime;
            clientPlayerState.dashVelocity = dashVelocity * dashDirection;
            
            // Apply immediate velocity boost for responsive feel
            clientPlayerState.velocityX += clientPlayerState.dashVelocity;
            
            // Apply movement immediately  
            const deltaTime = 1 / PHYSICS_CONSTANTS.FRAME_RATE;
            clientPlayerState.x += clientPlayerState.dashVelocity * deltaTime;
            
            // Update sprite position immediately
            if (playerSprites[myPlayerId]) {
                playerSprites[myPlayerId].setPosition(clientPlayerState.x, clientPlayerState.y);
                updateLocalPlayerHealthBar();
            }
            
                             // Reduced logging - only for debugging
        }
        
        function bufferInput(inputs) {
            // Store input with timestamp for server reconciliation
            inputBuffer.push({
                inputs: { ...inputs },
                timestamp: Date.now(),
                clientState: { ...clientPlayerState }
            });
            
            // Keep buffer size manageable (last 1 second of inputs)
            const oneSecondAgo = Date.now() - 1000;
            inputBuffer = inputBuffer.filter(entry => entry.timestamp > oneSecondAgo);
        }
        
        function reconcileWithServer(serverState) {
            if (!clientPlayerState || !predictionEnabled) return;
            
            const serverPlayer = serverState.players[myPlayerId];
            if (!serverPlayer) return;
            
            // Handle edge cases: player death, elimination, or major state changes
            if (serverPlayer.isDead || serverPlayer.eliminated || serverPlayer.health <= 0) {
                // Force sync to server state for edge cases to prevent large errors
                clientPlayerState.x = serverPlayer.x;
                clientPlayerState.y = serverPlayer.y;
                clientPlayerState.velocityX = serverPlayer.velocityX || 0;
                clientPlayerState.velocityY = serverPlayer.velocityY || 0;
                clientPlayerState.isGrounded = serverPlayer.isGrounded;
                clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
                clientPlayerState.health = serverPlayer.health;
                
                if (playerSprites[myPlayerId]) {
                    playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y);
                    updateLocalPlayerHealthBar();
                }
                
                lastServerUpdate = Date.now();
                updateDebugPanel();
                return;
            }
            
            // Calculate position difference
            const positionError = Math.sqrt(
                Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                Math.pow(clientPlayerState.y - serverPlayer.y, 2)
            );
            
            // SIMPLIFIED: Much more conservative reconciliation for high latency
            // Use larger error thresholds to prevent jitter
            const ERROR_THRESHOLD = 50; // Generous threshold for 150ms latency
            const LARGE_ERROR_THRESHOLD = 100; // Threshold for immediate correction
            
            // Conservative correction factors to prevent oscillation
            let correctionFactor = 0.1; // Very gentle base correction
            
                         if (positionError > LARGE_ERROR_THRESHOLD) {
                 // Large error - use moderate correction to avoid snapping
                 correctionFactor = 0.3;
                 // Only log extreme corrections to avoid spam
                 if (positionError > 200) {
                     console.log(`[PREDICTION] Extreme correction: ${positionError.toFixed(1)}px`);
                 }
             } else if (positionError > ERROR_THRESHOLD) {
                // Medium error - gentle correction
                correctionFactor = 0.15;
            } else {
                // Small error - no correction needed, let prediction run
                correctionFactor = 0;
            }
            
            // Apply correction only if needed
            if (correctionFactor > 0) {
                // Smooth interpolation towards server position
                clientPlayerState.x += (serverPlayer.x - clientPlayerState.x) * correctionFactor;
                clientPlayerState.y += (serverPlayer.y - clientPlayerState.y) * correctionFactor;
                
                // Gentle velocity sync only for large errors
                if (positionError > LARGE_ERROR_THRESHOLD) {
                    clientPlayerState.velocityX = serverPlayer.velocityX || 0;
                    clientPlayerState.velocityY = serverPlayer.velocityY || 0;
                }
                
                // Apply corrected position to sprite
                if (playerSprites[myPlayerId]) {
                    playerSprites[myPlayerId].setPosition(clientPlayerState.x + 200, clientPlayerState.y);
                    updateLocalPlayerHealthBar();
                }
            }
            
            // Always sync critical non-position state
            clientPlayerState.isGrounded = serverPlayer.isGrounded;
            clientPlayerState.jumpsRemaining = serverPlayer.jumpsRemaining;
            clientPlayerState.health = serverPlayer.health;
            
            lastServerUpdate = Date.now();
            updateDebugPanel();
        }
        
        let lastDebugUpdate = 0;
        const DEBUG_UPDATE_INTERVAL = 300; // Update debug panel only every 300ms for better performance
        
        function updateDebugPanel() {
            const now = Date.now();
            if (now - lastDebugUpdate < DEBUG_UPDATE_INTERVAL) return;
            lastDebugUpdate = now;
            
            const predictionStatusEl = document.getElementById('prediction-status');
            predictionStatusEl.textContent = predictionEnabled ? 'ON' : 'OFF';
            predictionStatusEl.style.color = predictionEnabled ? '#66ff66' : '#ff6666';
            document.getElementById('buffer-size').textContent = inputBuffer.length;
            document.getElementById('server-time').textContent = (now - lastServerUpdate).toFixed(0) + 'ms ago';
            
            // Enhanced position error tracking for high latency debugging
            if (predictionEnabled && clientPlayerState && gameState.players[myPlayerId]) {
                const serverPlayer = gameState.players[myPlayerId];
                const positionError = Math.sqrt(
                    Math.pow(clientPlayerState.x - serverPlayer.x, 2) + 
                    Math.pow(clientPlayerState.y - serverPlayer.y, 2)
                );
                
                // Calculate velocity error for debug display
                const serverVelX = serverPlayer.velocityX || 0;
                const serverVelY = serverPlayer.velocityY || 0;
                const velocityError = Math.sqrt(
                    Math.pow(clientPlayerState.velocityX - serverVelX, 2) + 
                    Math.pow(clientPlayerState.velocityY - serverVelY, 2)
                );
                
                // Enhanced error display with color coding
                let errorText = positionError.toFixed(1);
                let errorColor = '#66ff66'; // Green for good
                
                if (positionError > 40) {
                    errorColor = '#ff6666'; // Red for bad
                    errorText += ` HIGH!`;
                } else if (positionError > 25) {
                    errorColor = '#ff9966'; // Orange for concerning
                    errorText += ` (high)`;
                } else if (positionError > 15) {
                    errorColor = '#ffff66'; // Yellow for moderate
                }
                
                const errorElement = document.getElementById('position-error');
                errorElement.textContent = errorText;
                errorElement.style.color = errorColor;
                
                // Add velocity error to debug if position error is high
                if (positionError > 15 || velocityError > 50) {
                    errorElement.textContent += ` | vel: ${velocityError.toFixed(1)}`;
                }
                
                // Show server tick rate if available
                if (gameState.tickRate) {
                    const tickElement = document.getElementById('server-tickrate');
                    if (tickElement) {
                        tickElement.textContent = `${gameState.tickRate}fps`;
                    }
                }
            } else {
                document.getElementById('position-error').textContent = '0.0';
                document.getElementById('position-error').style.color = '#66ff66';
            }
        }
        
        function handleJumpEvent(jumpEvent) {
            // Handle jump event for visual effects (particle effects, sound, etc.)
            const playerSprite = playerSprites[jumpEvent.playerId];
            if (!playerSprite) return;
            
            // Visual feedback for jumps
            const jumpEffect = this.add.circle(jumpEvent.position.x + 200, jumpEvent.position.y + 30, 15, 0xFFFF00, 0.7);
            jumpEffect.setDepth(1000); // Render on top
            
            // Animate the effect
            this.tweens.add({
                targets: jumpEffect,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 300,
                ease: 'Power2',
                onComplete: () => {
                    jumpEffect.destroy();
                }
            });
            
            // Different effects for single vs double jump
            if (jumpEvent.jumpType === 'double') {
                // Add sparkle effect for double jump
                const sparkle = this.add.circle(jumpEvent.position.x + 200, jumpEvent.position.y + 25, 8, 0xFF00FF, 0.9);
                sparkle.setDepth(1001);
                
                this.tweens.add({
                    targets: sparkle,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    alpha: 0,
                    duration: 200,
                    ease: 'Power1',
                    onComplete: () => sparkle.destroy()
                });
            }
        }
        
        function handleDashEvent(dashEvent) {
            // Handle dash event for visual effects (particle trail, sound, etc.)
            const playerSprite = playerSprites[dashEvent.playerId];
            if (!playerSprite) return;
            
            // Visual feedback for dash - create trail effect
            const dashTrail = this.add.rectangle(
                dashEvent.position.x + 200, 
                dashEvent.position.y, 
                60, 
                20, 
                0x00FFFF, 
                0.6
            );
            dashTrail.setDepth(999); // Render behind player but above background
            
            // Animate the trail effect
            this.tweens.add({
                targets: dashTrail,
                scaleX: dashEvent.direction === 'left' ? -0.2 : 0.2,
                scaleY: 0.5,
                alpha: 0,
                duration: 200,
                ease: 'Power2',
                onComplete: () => {
                    dashTrail.destroy();
                }
            });
            
            // Add directional speed lines
            for (let i = 0; i < 3; i++) {
                const speedLine = this.add.rectangle(
                    dashEvent.position.x + 200 + (dashEvent.direction === 'left' ? 20 : -20) * (i + 1), // Add 200px offset
                    dashEvent.position.y + (Math.random() - 0.5) * 30,
                    15,
                    3,
                    0xFFFFFF,
                    0.8
                );
                speedLine.setDepth(998);
                
                this.tweens.add({
                    targets: speedLine,
                    x: speedLine.x + (dashEvent.direction === 'left' ? -30 : 30),
                    alpha: 0,
                    duration: 150 + i * 50,
                    ease: 'Linear',
                    onComplete: () => speedLine.destroy()
                });
            }
            
            console.log(`Dash visual effect for player ${dashEvent.playerId} direction ${dashEvent.direction}`);
        }
        
        function handleDashInterruption(interruptEvent) {
            // Handle dash interruption for visual effects cleanup
            const playerSprite = playerSprites[interruptEvent.playerId];
            if (!playerSprite) return;
            
            // Clean up any active dash visual effects
            this.children.getChildren().forEach(child => {
                if (child.name && (child.name.includes('dashTrail') || child.name.includes('speedLine'))) {
                    child.destroy();
                }
            });
            
            // Visual feedback for dash interruption (brief flash effect)
            if (playerSprite) {
                this.tweens.add({
                    targets: playerSprite,
                    alpha: 0.5,
                    duration: 100,
                    yoyo: true,
                    ease: 'Power2'
                });
            }
            
            console.log(`Dash interrupted for player ${interruptEvent.playerId}: ${interruptEvent.reason}`);
        }
        
        function handlePlayerDeath(deathEvent) {
            console.log(`Player ${deathEvent.playerId} died! Lives remaining: ${deathEvent.livesRemaining}`);
            
            // Create death effect at death position
            const deathEffect = this.add.circle(deathEvent.deathPosition.x + 200, deathEvent.deathPosition.y, 50, 0xff0000, 0.8);
            deathEffect.setDepth(1000);
            
            // Animate death effect
            this.tweens.add({
                targets: deathEffect,
                scaleX: 3,
                scaleY: 3,
                alpha: 0,
                duration: 500,
                ease: 'Power2',
                onComplete: () => deathEffect.destroy()
            });
            
            // Handle local player death with countdown and fade effects
            if (deathEvent.playerId === myPlayerId && !deathEvent.isEliminated) {
                // Screen shake for local player death
                this.cameras.main.shake(300, 0.02);
                
                // Start fade effect on player sprite
                if (playerSprites[myPlayerId]) {
                    this.tweens.add({
                        targets: playerSprites[myPlayerId],
                        alpha: 0.2,
                        duration: 3000, // Fade over 3 seconds
                        ease: 'Linear'
                    });
                }
                
                // Start respawn countdown
                startRespawnCountdown();
            }
            
            // For other players, just fade their sprite
            if (deathEvent.playerId !== myPlayerId && playerSprites[deathEvent.playerId]) {
                this.tweens.add({
                    targets: playerSprites[deathEvent.playerId],
                    alpha: 0.3,
                    duration: 1000,
                    ease: 'Power2'
                });
            }
        }
        
        function startRespawnCountdown() {
            const countdownElement = document.getElementById('respawn-countdown');
            let timeLeft = 3;
            
            function updateCountdown() {
                if (timeLeft > 0) {
                    countdownElement.textContent = timeLeft;
                    countdownElement.style.display = 'block';
                    
                    // Pulse effect for countdown
                    countdownElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        countdownElement.style.transform = 'translate(-50%, -50%) scale(1.0)';
                    }, 200);
                    
                    timeLeft--;
                    setTimeout(updateCountdown, 1000);
                } else {
                    countdownElement.style.display = 'none';
                }
            }
            
            updateCountdown();
        }
        
        function handlePlayerRespawn(respawnEvent) {
            console.log(`Player ${respawnEvent.playerId} respawned with invincibility`);
            
            // Restore sprite alpha for respawned player
            if (playerSprites[respawnEvent.playerId]) {
                // Stop any existing fade tweens
                this.tweens.killTweensOf(playerSprites[respawnEvent.playerId]);
                // Restore full alpha
                playerSprites[respawnEvent.playerId].setAlpha(1.0);
            }
            
            // Create respawn effect
            const respawnEffect = this.add.circle(respawnEvent.position.x + 200, respawnEvent.position.y, 30, 0x00ffff, 0.7);
            respawnEffect.setDepth(1000);
            
            // Animate respawn effect
            this.tweens.add({
                targets: respawnEffect,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => respawnEffect.destroy()
            });
            
            // Add sparkle effects
            for (let i = 0; i < 8; i++) {
                const sparkle = this.add.circle(
                    respawnEvent.position.x + 200 + (Math.random() - 0.5) * 60, // Add 200px offset
                    respawnEvent.position.y + (Math.random() - 0.5) * 60,
                    3,
                    0xffffff,
                    0.9
                );
                sparkle.setDepth(1001);
                
                this.tweens.add({
                    targets: sparkle,
                    scaleX: 2,
                    scaleY: 2,
                    alpha: 0,
                    duration: 300 + Math.random() * 200,
                    ease: 'Power1',
                    onComplete: () => sparkle.destroy()
                });
            }
            
            // Hide countdown for local player
            if (respawnEvent.playerId === myPlayerId) {
                const countdownElement = document.getElementById('respawn-countdown');
                countdownElement.style.display = 'none';
            }
        }
        
        function handlePlayerElimination(eliminationEvent) {
            console.log(`Player ${eliminationEvent.playerId} eliminated!`);
            
            // Create elimination effect
            const eliminationEffect = this.add.circle(eliminationEvent.finalPosition.x + 200, eliminationEvent.finalPosition.y, 80, 0xff6600, 0.9);
            eliminationEffect.setDepth(1000);
            
            // Animate elimination effect
            this.tweens.add({
                targets: eliminationEffect,
                scaleX: 4,
                scaleY: 4,
                alpha: 0,
                duration: 800,
                ease: 'Power3',
                onComplete: () => eliminationEffect.destroy()
            });
            
            // Add text effect
            const eliminationText = this.add.text(eliminationEvent.finalPosition.x + 200, eliminationEvent.finalPosition.y - 50, 'ELIMINATED!', {
                fontSize: '24px',
                fill: '#ff6600',
                stroke: '#000000',
                strokeThickness: 2
            });
            eliminationText.setOrigin(0.5);
            eliminationText.setDepth(1001);
            
            this.tweens.add({
                targets: eliminationText,
                y: eliminationText.y - 100,
                alpha: 0,
                duration: 1000,
                ease: 'Power2',
                onComplete: () => eliminationText.destroy()
            });
        }
        
        function handleMatchEnd(matchEndEvent) {
            console.log(`Match ended! Winner: ${matchEndEvent.winnerId}`);
            
            // Create match end overlay
            const overlay = this.add.rectangle(600, 500, 1200, 1000, 0x000000, 0.7); // Expanded to 1200x1000, centered at (600, 500)
            overlay.setDepth(2000);
            
            // Winner text
            const winnerText = matchEndEvent.winnerId === myPlayerId ? 'YOU WIN!' : 
                              matchEndEvent.winnerId ? 'MATCH OVER' : 'DRAW!';
            const winnerColor = matchEndEvent.winnerId === myPlayerId ? '#00ff00' : '#ffffff';
            
            const matchEndText = this.add.text(600, 400, winnerText, { // Centered at 600 for 1200px canvas
                fontSize: '48px',
                fill: winnerColor,
                stroke: '#000000',
                strokeThickness: 3
            });
            matchEndText.setOrigin(0.5);
            matchEndText.setDepth(2001);
            
            // Final standings text
            let standingsText = 'Final Standings:\n';
            matchEndEvent.finalStandings.forEach((standing, index) => {
                const position = index + 1;
                const playerText = standing.playerId === myPlayerId ? 'YOU' : `Player ${standing.playerId.slice(-4)}`;
                standingsText += `${position}. ${playerText} - ${standing.lives} lives\n`;
            });
            
            const standingsDisplay = this.add.text(600, 550, standingsText, { // Centered at 600 for 1200px canvas
                fontSize: '18px',
                fill: '#ffffff',
                align: 'center'
            });
            standingsDisplay.setOrigin(0.5);
            standingsDisplay.setDepth(2001);
            
            // Store overlay elements for cleanup
            this.matchEndOverlay = [overlay, matchEndText, standingsDisplay];
        }
        
        function handleMatchReset(resetEvent) {
            console.log('Match reset - new round starting!');
            
            // Clean up match end overlay
            if (this.matchEndOverlay) {
                this.matchEndOverlay.forEach(element => element.destroy());
                this.matchEndOverlay = null;
            }
            
            // Create new round announcement
            const newRoundText = this.add.text(600, 500, 'NEW ROUND!', { // Centered at 600 for 1200px canvas
                fontSize: '36px',
                fill: '#ffff00',
                stroke: '#000000',
                strokeThickness: 2
            });
            newRoundText.setOrigin(0.5);
            newRoundText.setDepth(1000);
            
            // Animate and remove announcement
            this.tweens.add({
                targets: newRoundText,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 2000,
                ease: 'Power2',
                onComplete: () => newRoundText.destroy()
            });
        }
        
        function handleInvincibilityEnd(invincibilityEvent) {
            console.log(`Player ${invincibilityEvent.playerId} invincibility ended`);
            
            // Visual feedback for invincibility ending (small flash effect)
            if (playerSprites[invincibilityEvent.playerId]) {
                const player = playerSprites[invincibilityEvent.playerId];
                this.tweens.add({
                    targets: player,
                    alpha: 0.3,
                    duration: 100,
                    yoyo: true,
                    repeat: 2,
                    ease: 'Power1'
                });
            }
        }
        
        // Game Over Functions
        function showGameOverScreen(gameOverData) {
            console.log('Showing game over screen:', gameOverData);
            
            // Update winner text
            winnerText.textContent = gameOverData.winnerId ? 
                `🏆 Winner: ${gameOverData.winnerName}` : 
                '🤝 Draw - No Winner';
            
            // Clear and populate stats table
            statsTbody.innerHTML = '';
            
            // Track numerical rank for non-DQ players
            let numericalRank = 1;
            
            gameOverData.playerStats.forEach((player, index) => {
                const row = document.createElement('tr');
                
                // Add special classes for winner, current player, and disconnected
                if (player.isWinner) {
                    row.classList.add('winner');
                }
                if (player.playerId === socket.id) {
                    row.classList.add('current-player');
                }
                if (player.disconnected) {
                    row.classList.add('disconnected');
                }
                
                // Display rank as DQ for disconnected players, otherwise show numerical position
                const rank = player.disconnected ? 'DQ' : `#${numericalRank}`;
                if (!player.disconnected) {
                    numericalRank++;
                }
                
                const playerDisplayName = player.playerName + (player.playerId === socket.id ? ' (You)' : '') + (player.disconnected ? ' [DISCONNECTED]' : '');
                
                row.innerHTML = `
                    <td>${rank}</td>
                    <td>${playerDisplayName}</td>
                    <td>${player.kills}</td>
                    <td>${player.deaths}</td>
                    <td>${player.kdr}</td>
                `;
                
                statsTbody.appendChild(row);
            });
            
            // Show/hide rematch button based on host status AND player count
            const activePlayers = gameOverData.playerStats.filter(player => !player.disconnected);
            const canRematch = isHost && activePlayers.length >= 2;
            
            console.log(`Rematch check - isHost: ${isHost}, activePlayers: ${activePlayers.length}, canRematch: ${canRematch}`);
            
            rematchBtn.style.display = canRematch ? 'block' : 'none';
            
            if (!canRematch && isHost && activePlayers.length < 2) {
                console.log('Rematch not available - need at least 2 active players');
            }
            
            // Show the game over screen
            gameOverScreen.style.display = 'block';
        }
        
        function hideGameOverScreen() {
            gameOverScreen.style.display = 'none';
        }
        
        function handleRematch() {
            if (!isHost) {
                showMessage('Only the host can start a rematch', 'error');
                return;
            }
            
            // Disable button to prevent multiple clicks
            rematchBtn.disabled = true;
            rematchBtn.textContent = 'Starting Rematch...';
            
            socket.emit('rematch', (response) => {
                if (response.success) {
                    hideGameOverScreen();
                    showMessage('Rematch starting!', 'success');
                } else {
                    showMessage(response.error, 'error');
                    // Re-enable button on error
                    rematchBtn.disabled = false;
                    rematchBtn.textContent = 'Rematch';
                }
            });
        }
        
        function handleReturnToLobby() {
            socket.emit('returnToLobby', (response) => {
                if (response.success) {
                    hideGameOverScreen();
                    // Show room UI again
                    roomUI.style.display = 'block';
                    showRoomLobby(currentRoom.code, isHost);
                    showMessage('Returned to lobby', 'success');
                } else {
                    showMessage(response.error, 'error');
                }
            });
        }
    </script>
</body>
</html> 